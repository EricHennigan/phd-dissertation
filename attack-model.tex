\chapter{Code Injection Attacks}\label{ch:attack}

\section{Brief Overview of Web Architecture}\label{ch:attack-sec:web-architecture}

Web developer and user demand for increased interactivity in web pages led Netscape to introduce the JavaScript\footnote{JavaScript has now been standardized as ECMAScript~\cite{ecma}} programming language as a means of enabling more dynamic behavior within a webpage.
Modern web browsers contain an embedded JavaScript virtual machine that enables the page to load and execute code that dynamically updating the page, even as the page is being parsed.
To embed JavaScript code into a webpage, HTML supports a \code{<script>} tag and page-embedded URLs support the \code{javascript:} protocol.
The HTML specification~\cite{html} establishes the following ways to embed JavaScript in a webpage:

\begin{enumerate}
 \item Inside an HTML tag:
The \code{<script>}, \code{<object>}, \code{<applet>}, and \code{<embed>} permit inclusion of JavaScript within the page.
Attackers commonly use inject code using the \code{<script>} tag because it supports direct inlining of JavaScript into the HTML document.
 \item As an event handler:
HTML specifies attributes for certain intrinsic events, e.g., key presses, mouse hovering or clicking, errors, page loading and unloading, and form submission.
The browser executes JavaScript code attached to an event every time the event triggers.
Often web authors designate the target script of an event handler using the \code{javascript:} URL scheme.
 \item As an HTML attribute:
HTML tags often provide an attribute (e.g., \code{src}, \code{data}, \code{content}) that allows loading JavaScript code from a separate URL.
%\texttt{script src="www.example.com/login.js"}.
\end{enumerate}


Web developers quickly began to take advantage of client-side scriptability to migrate application logic to the client's browser in order to reduce the load on web servers.
As a result, users now enjoy many new web applications that demonstrate increased interactivity and responsiveness reminiscent of traditional desktop applications.

\subsection{The DOM Environment}\label{sec:dom}
To support the dynamic modification of a webpage that has already been retrieved from the web server, the browser exposes an interface known as the \term{Document Object Model (DOM)}~\cite{dom}.
This interface allows scripts in a page to reference, through a hierarchical tree of JavaScript objects, any HTML element of that page.
For example, a form input element can be accessed by name using \code{document.formName.inputName} or through the HTML hierarchy as \code{document.forms[0].elements[0]}.
The DOM not only allows the addressing and modification of page elements through the \code{document} object, but also makes available certain aspects of the browser environment through the \code{window}, \code{navigator}, \code{screen}, \code{history}, and \code{location} objects.
Security within a web browser often focuses on preventing the content of these objects and page data from being modified or purloined by arbitrary JavaScript code.
The multitude of syntaxes for accessing page elements complicates auditing web applications for security vulnerabilities.

%\subsection{AJAX}
%Microsoft released Outlook Web Access 2000 with the goal of enhancing user interaction and lessening server load by keeping a persistent user interface loaded as a single web browser page, even as the user viewed different emails.
%Achieving this effect required the invention of a means to request raw data from a web server without performing any page navigation in the browser.
%This requirement led to the introduction of the \code{XMLHttpRequest} object, which asynchronously fetches data in the background while the displayed page remains responsive to user events.
%Other vendors quickly realized the potential of this technology, so that by 2005 it became supported as a standard in major browsers.
%
%User's experience of interactive applications on the Web has been taken to a new level, christened Web~2.0~\cite{web20def}, through a collection of technologies labeled Asynchronous JavaScript and XML\footnote{XML (eXtensible Markup Language) is a popular data interchange format that consists of paired tags definable by the developer in an \emph{XML schema}.} (AJAX), which incorporates the following parts~\cite{garrett05}:
%\begin{itemize}
% \item standards-based presentation using style sheets;
% \item dynamic display and interaction using the Document Object Model;
% \item data interchange and manipulation using standardized formats;
% \item asynchronous data retrieval using \texttt{XMLHttpRequest};
% \item and JavaScript code binding everything together.
%\end{itemize}
%
%AJAX enables developers to write webpages with improved user interfaces.
%These pages are able to dynamically update in response to newly available information, without requiring a page refresh.
%For example, an early web-based email application required the user to refresh the page showing the inbox to check for new mail.
%With the introduction of client-side code and dynamically updatable page content, a webmail application is now able to periodically check with the mail sever for new mail without user intervention, even issuing a notification of new mail.

\section{The Many Types of XSS}\label{ch:attack-sec:xss-types}

Attackers exploit the code-injection vulnerability known as Cross-site scripting by insertion JavaScript or other code into a webpage, causing viewers of that page to unwittingly execute malicious code.
The following examples inject benign code as a proof-of-concept demonstrating the code insertion vulnerability.

In a realistic scenario, the attacker might use the inserted code to harvest user information such as login credentials, for imitating a user or hijacking their browsing session (\autoref{ch:attack-sec:xss-uses}), or credit card numbers, for engaging in fraud.

We classify XSS into four categories, according to the origin of the injected code: \term{Local} (\autoref{sec:xss-types-local}), \term{Reflected} (\autoref{sec:xss-types-reflected}), \term{Semi-Persistent} (\autoref{sec:xss-types-semipersistent}), and \term{Persistent} (\autoref{sec:xss-types-persistent}).

\subsection{Local or DOM-Based XSS}\label{sec:xss-types-local}

Klein \cite{localXSS} explores a local XSS attack that does not require a vulnerability in the web server.
Instead, the vulnerability lies within a static page that the originating server does not dynamically process.
For example, consider a webpage that contains a customized greeting message for each user.
The page delivered by the web server contains code that reads the query string of the URL to obtain the user's name, which in turn updates the greeting message.
The processing occurs locally, on the user's browser.

The example in \autoref{list:xss-local} contains a concrete demonstration of this vulnerability.
The HTML contains a \code{<p>} tag for the insertion of a paragraph of text into the page.
The JavaScript after the paragraph tag modifies the paragraph contents to insert the \code{name} variable from the current URL.
Thus, the text `\code{Hello Guest}' replaces part of the current URL.
By modifying the \code{name} parameter in the url to contain an HTML \code{<script>} tag, a malicious user can cause the browser to execute a call to \code{evil\_code}.
Because all JavaScript execution occurs on the client-side within the user's browser, the attack requires no cooperation from the server except page retrieval.

\lstset{
  label=list:xss-local,
  caption={A local XSS vulnerability.}
}
\begin{jscode}
<body>
    <p id="hello">Hello Guest</p>
    <script language="javascript">
        var beg = document.URL.indexOf("name=")+5
        var end = document.URL.indexOf("\&", beg)
        if (end==-1) end = document.URL.length
        var welcomestr = "Hello " + document.URL.substring(beg, end)
        document.getElementById("hello").innerHTML = welcomestr;
    </script>
</body>
\end{jscode}

\lstset{
  label=list:xss-local-exploit,
  caption={Exploiting the Local XSS vulnerability in \autoref{list:xss-local}.}
}
\begin{exploit-example}
A URL used to greet a user named Bob:
(*\url{http://www.ex.com/welcome.html?name=Bob}*)
A script injection that causes execution of JavaScript code:
(*\url{http://www.ex.com/welcome.html?name=<script>evil_code()</script>}*)
\end{exploit-example}

Web authors can mitigate this attack by first encoding embedded data in the URL so that innocuous (HTML encoded) equivalents replace any special characters (e.g., `\code{<}' and `\code{>}') before insertion into the page.
Sanitization forces the browser to interpret the injected text as data rather than code.
The availability of web services that replace a URL with a hash code (e.g., TinyURL), or that provide automated HTTP forwarding or redirection, permit an attacker to easily mask the malicious contents of the URL before delivering it to an innocent user.

\begin{description}
 \item[Vulnerability:] \hfill \\
   Any static webpage that can self-modify its contents using data from \code{document.location}, \code{document.URL}, \code{document.referrer} or other attacker-controlled DOM property.
 \item[Method of Exploitation:] \hfill
  \begin{enumerate}
   \item Attacker embeds malicious script into local data source (URL or DOM element).
   \item Victim opens the page in their browser.
   \item Trusted code on the page loads the malicious script from the local data source.
   \item Victim's browser executes the malicious script in the context of the original page.
  \end{enumerate}
\end{description}

\subsection{Reflected or Non-Persistent XSS}\label{sec:xss-types-reflected}

A reflected XSS attack exploits the behavior of web servers configured to return pages that incorporate data originating from a client-side request.
Applications commonly use such data to provide customized page contents to the user.
If the application fails to sanitize the data, a malicious user can insert a script into the request.
This causes the web server to inject the script into the returned page.
As an example, consider a search engine that echoes back the search query submitted in the query string of a~URL.

\lstset{
  label=list:xss-reflected,
  caption={A reflected XSS vulnerability.}
}
\begin{jscode}
<p>
    Your search for <?php echo(GET["query"]); ?>
    returned the following results:
</p>
\end{jscode}

\lstset{
  label=list:xss-reflected-exploit,
  caption={Exploiting the reflected XSS vulnerability in \autoref{list:xss-reflected}.}
}
\begin{exploit-example}
An ordinary search for the term `example':
(*\url{http://www.ex.com/search.php?query=example}*)
A malicious `search' that causes execution of JavaScript code:
(*\url{http://www.ex.com/search.php?query=<script>evil_code()</script>}*)
\end{exploit-example}

Because the server inserts the malicious code into the page, the victim's browser cannot distinguish it from any other code on the page.
It executes the malicious script in exactly the same manner, and with the same trust, as any other script on the returned page.
Researchers describe this attack as \term{reflected} because the script originates from the client and gets reflected back after the server embeds it into the returned page.
Unfortunately, this type of attack cannot be easily detected by a divergence from the expected behavior of the web application, because a clever attacker can almost always construct a payload that, from the victim's perspective, does not affect the functionality of the page.

\begin{description}
 \item[Vulnerability:] \hfill \\
    Any webpage that the server dynamically assembles by incorporating unsanitized client-supplied data.
 \item[Method of Exploitation:] \hfill
  \begin{enumerate}
   \item Attacker embeds malicious script into a temporary data source (URL query string, form fields, etc).
   \item Victim requests a page, with malicious data as part of the request.
   \item Server returns a page with the malicious script inserted.
   \item Victim's browser executes the malicious script on the page, as if it originated from the server itself.
  \end{enumerate}
\end{description}

%\textcolor{red}{Do we want a reflected-encoded subsection [Kals et al. 2006] or do we cover that point in a section about filtering?}

\subsection{Semi-Persistent XSS}\label{sec:xss-types-semipersistent}

Kachel~\cite{semipersistent} identifies another type of XSS attack that involves injecting a malicious script into a user's cookie.
This vulnerability exists if a web application creates cookie data from content in a URL or HTML form.
An attacker can prepare a malicious URL or HTML form that causes the web server receiving the request to issue a cookie containing malicious script to the user.
The browser includes the poisoned cookie in all subsequent HTTP messages with the web application for as long as the cookie remains unexpired.
If the web application uses information from an issued cookie to dynamically create pages, then the malicious script can also migrate from the cookie to a page (as in a reflected attack, \autoref{sec:xss-types-reflected}).

Because cookies are created and maintained by web servers, ordinary users rarely inspect their cookies, and web developers have become accustomed to implicitly trusting the data contained in cookies their own server issued.
The storage of a malicious script inside the user's cookie makes this type of attack \term{semi-persistent}.
It lasts longer than the data sources involved in a reflected attack, but eventually disappears either when the user closes their browser or when the cookie expires.

\begin{description}
 \item[Vulnerability:] \hfill \\
   Web application that inserts unsanitized cookie data stored by the client into a page dynamically assembled by the server.
 \item[Method of Exploitation:] \hfill
  \begin{enumerate}
   \item Attacker constructs a malicious URL or pre-filled HTML form.
   \item Victim visits the URL or submits the form, sending the malicious data as part of the HTTP request.
   \item Server issues a cookie to the victim containing malicious content derived from the HTTP request.
   \item Web application constructs a page with the malicious content from the cookie.
   \item Victim's browser executes the malicious script on the page.
  \end{enumerate}
\end{description}

\subsection{Persistent XSS}\label{sec:xss-types-persistent}

The most pernicious type of XSS attack allows the injected script to persist between sessions.
It achieves full persistence by infecting a server-side data store.
The canonical example of such an attack involves a message board or web forum that allows the posting of user-generated content.
The application stores this content in a server-side database, for retrieval and viewing by other visitors.
If a malicious user successfully injects JavaScript into a forum posting, the site saves the script and inserts it into all pages that contain the post.
To become a victim, a user only needs to view a page with the malicious post.

\begin{description}
 \item[Vulnerability:] \hfill \\
   Web application that stores user-supplied data into a server-side data store.
   It then inserts the data into dynamically assembled pages delivered to all users.
 \item[Method of Exploitation:] \hfill
  \begin{enumerate}
   \item Attacker submits a malicious entry into the web application.
   \item Victim uses the web application and views a page containing the malicious entry.
   \item Server inserts content from the malicious entry into a page of the application.
   \item Victim's browser executes malicious script embedded in the page, and trusts it as originating from the application server.
  \end{enumerate}
\end{description}

\subsection{Content-Sniffing XSS}\label{sec:xss-types-content}

Barth et al.~\cite{barth.etal+09b} highlight a special case of a persistent XSS attack that exploits the difference between browser and server behavior in identifying MIME types.
A rather humorous example of such an attack involves a web-based paper submission system.
A malicious author creates a \emph{chameleon} document for peer-review, such as a PDF with a forged header containing HTML and JavaScript.
The site upload filters detect and scan the document, accepting it as a valid PDF.
Later, a reviewer uses their browser to download and view the PDF.
Their browser erroneously detects the file as HTML, rendering and processing the contained JavaScript within the context of the review page.
The malicious author now has an opportunity to craft the payload JavaScript such that it fills out forms with a favorable review.

\begin{description}
 \item[Vulnerability:] \hfill \\
   Web application that stores a user-supplied document into a server-side data store.
   The site then makes the document viewable to other web browsers.
   The document exploits a difference between server-side MIME detection, and client-side content-sniffing algorithms, causing the browser to interpret the document and execute a malicious script.
 \item[Method of Exploitation:] \hfill
 \begin{enumerate}
  \item Attacker submits a \emph{chameleon} document, conforming to two different MIME types.
  \item Server performs MIME detection, and accepts the document as an allowed MIME type.
  \item Victim uses the web application to view the uploaded document.
  \item Victim's browser overrides the server's MIME description using its own content-sniffing algorithm.
  \item Victim's browser processes HTML/JavaScript contained in the document.
 \end{enumerate}
\end{description}

\subsection{Summary}

The presence of an XSS vulnerability on a popular web application allows attackers to inject arbitrary code into the browsers of innocent users.
Most websites generate popularity from their encouragement of user participation.
Such community-driven websites host user-generated content, making them particularly desirable and exploitable, targets.
Because most exploits aim at executing JavaScript within a browser, the injection techniques derive their forcefulness from weaknesses in existing Web infrastructure, standards, and common practices.
As a result, XSS exploits remain generally OS and browser agnostic, granting them an amazingly large scope of potential victims.
The difficulty in distinguishing JavaScript exploit code from normal web page markup~\cite{xss-history} makes XSS attacks difficult to detect.

\section{Historical Uses of XSS}\label{ch:attack-sec:xss-uses}

Attackers benefit from XSS vulnerabilities because the browser executes the injected code in the context of the original page or web application.
The victim's browser misidentifies the code as being a legitimate part of the requested page, with the result that the malicious code subverts any security protections (such as the same-origin policy \autoref{sec:same-origin}) and acquires the same access and privileges as all other code on the page.
The examples in \autoref{ch:attack-sec:xss-types} demonstrated this point, but did so in a way that indicated XSS might be of a fairly low-profile or merely irritating nature.
Though attackers can use code injection attacks to detract from user experience by defacing the visited page or changing user settings at a public forum, we prefer to draw attention to some examples of more serious ways in which XSS vulnerabilities have affected large businesses employing professional web application designers.

\subsection{The `Samy' Worm}
MySpace~\cite{myspace} operates a social networking website that allows users to create their own webpages.
A user's default page features a friends list, a heroes list, a blog, and shared profile information.
Samy Kamak~\cite{samy} wrote a small piece of JavaScript code that performed three tasks when a user viewed an infected profile: (1) alter the victim's profile to declare ``but most of all, Samy is my hero'', (2) added Samy to the victim's list of heroes and friends by generating a `friend request' to the code author, and (3) injected itself into the victim's profile to further propagation.
Through a vulnerability that allowed bypassing the sanitization and filtering mechanisms that MySpace applied to all user input, Kamkar initiated the infection by placing the code on his own profile.
The worm itself used an \code{XMLHttpRequest} to perform its tasks without user intervention or knowledge.
Within 20 hours, the author had received over 1 million friend requests, setting a world record for viral spreading, and forcing MySpace to suspend service in order to purge the worm from their database.

\subsection{The `Yamanner' Worm}
In 2006, a JavaScript worm named JS.Yamanner@m~\cite{yamanner} infected the Yahoo! Mail Beta service and remains notable for being the first such XSS exploit.
In order to protect both themselves and users, Yahoo! implemented filtering mechanisms designed to neutralize JavaScript and certain HTML expressions from the body of an email before displaying it within the webmail application.
Without such protections, the mere opening of an email containing injected JavaScript code would trigger execution of that code inside the victim's browser.
The author of the JS.Yamanner@m attack crafted an email containing JvaScript that bypassed Yahoo!'s sanitization filters.


\lstset{
  label=list:yamanner,
  caption={Illustration of the URL vulnerability exploited by JS.Yamanner@m.}
}
\begin{jscode}
<img src='http://images.yahoo.com/mail_logo.gif'
  target=""onload="alert(document.cookie)">
\end{jscode}

Yahoo!'s sanitization routines stripped the \code{target=""} piece from the URL.
This action still left a valid \code{img} tag with an in-tact \code{onload} attribute.
For presentation, the example in \autoref{list:yamanner} substitutes the malicious JavaScript code used in the attack with the more benign \code{alert(document.cookie)}.
The actual attack code used an \code{XMLHttpRequest} to scan the user's address book and previous mail history, collecting a large number of email addresses.
In order to further its propagation, the worm then composed an email (containing itself) to each of the victim's contacts.
The worm also placed the addresses in an HTTP request to \code{av3.net}, which allowed the site administrator to collect the addresses merely by scanning the server logs.
Yahoo! sucessfully stopped the execution and propagation of the worm by updating their sanitization routines.

\subsection{RightMedia Trojan}\label{sec:advertisement}
Many websites include within their applications code for dynamically fetching advertisements from third-party suppliers.
Because of existing business relationships, many clients wrote their web application to inline the advertisements rather than sandboxing it.
In one instance, the advertisement provider RightMedia supplied popular web sites such as Yahoo! Photobucket and MySpace banner advertisements that contained malicious code~\cite{adjacking}.
Though the supplied payload targeted a vulnerability specific to Internet Explorer into order to install a generic trojan horse on the user's operating system, the attacker could have been constructed it to perform a browser-agnostic XSS attack against the site it gets delivered to.

\subsection{Nduja Connection}
Valotta~\cite{nduja} authored ``Cross Webmail Worm'' able to propagate itself across four most popular webmail providers in Italy.
The worm detected which which domain the victim used to view the webmail, and took the appropriate XSS actions for that domain.
In each case, it followed the classical model of (1) scraping the users' contacts by examining past email or via an \code{XMLHttpRequest}, (2) acquiring any authorization tokens necessary for sending email, and (3) sending itself to all the addresses that the victim had corresponded with.
For each of the four webmail providers, the attacker developed separate functionality for both infection and propagation, making this worm the first to spread across different web applications.
Fortunately, the author cared more about making a point concerning advanced XSS techniques than about pilfering the confidential information held in victims' inboxes.

\subsection{XSS Threat Summary}
Though dated, these examples remain notable not only for setting records, but also for demonstrating the relative ease with which a clever user can control the actions taken by millions of other browsers.
Consider also, that many web users do not often close down their browser session and rely on timeouts to log out of web applications.
Consequently they remain simultaneously logged into other more sensitive services (such as email, shopping, banking or brokerage accounts).
With these common practices, the potential for harvesting of sensitive user credentials becomes a serious threat.

We would also like to remind the reader that your web browser probably knows more about your habits, interests, and other personally identifying information than any other single application.
In addition, it probably also stores login credentials to banking sites, webmail services, and many shopping sites, as well as form information containing your real name, address, phone number, and credit card numbers.

%\section{What Can Be Done With XSS}
%In principle, much more can be accomplished using by XSS as an initial bootstrapping technique for a more nefarious attack.
%In this section we wish to highlight some of the more notable uses

%\subsection{Future XSS attacks}
%As Web 2.0 moves forward and more services are moved ``into the cloud'', we see a demand for the improvement of client-side hardware and more powerful client-side technologies.
%Such developments certainly make web applications into more desirable targets.
%We should expect that XSS exploits increase in sophistication and begin to use more powerful mechanisms already found in traditional worms, viruses and trojans~\cite{xss-worms}:
%\begin{itemize}
% \item command-and-control channels to direct the actions taken by hostage browsers,
% \item subtler payloads that perform malicious activities without affecting ordinary user expectations,
% \item polymorphic payloads aimed at defeating detection and identification systems,
% \item the use of a hostage browser to act as a vulnerability scanner on every site that the victim visits,
% \item remaining dormant during propagation to avoid attention.
%\end{itemize}

\section{Architectural Defects of the Web}\label{ch:attack-sec:web-defects}

The ad-hoc evolution of the Web has resulted in a profoundly insecure architecture, with respect to code injection attacks.
In particular, three facets of the current architecture have an important impact on security.
The anatomy of an HTML page, which includes formatting commands inline with the textual content, remains central to the issue of code injection and makes HTML particularly prone to the insertion of nefarious control sequences.

Security advocates heavily promote~\cite{owasp, cwe, whitehat} the use of filter and sanitization routines that reject or escape HTML and JavaScript code from user input to prevent script injection attacks.
Though user input filtering forms the first line of security defense of any website, web applications can not reliably identify every malicious script.
Web frameworks, which lack strong, static code analysis, further compound the problem because they cannot provably verify that all strings pass through a filter function before placement into the resulting page.
The most popular languages used for the web, JavaScript, PHP, ASP, Ruby, Python, and Perl, all fall into this category.

\subsection{Encoding}\label{sec:encoding}
Web application designers construct their pages using various interrelated technologies: URLs for resource requests, HTML for page layout, CSS for content layout, JavaScript for page code, the JavaScript Object Notation (JSON) or XML for object and data description, etc.
Each of these technologies has its own specification and set of allowed characters.
Sites now use so many different character encodings that it developers have great difficultly tracking the language context that a user-supplied string might appear in and how the many different browsers might interpret the string in that context.

These many different encodings allow an attacker to formulate strings that behave benignly in one context, but have nefarious effects when parsed or rendered in a different context.
For example, characters such as `\code{<}', which has special meaning in HTML, has many different encodings (\autoref{tab:html-encoding}).
The historic design philosophy of `being liberal in what you accept from others'~\cite{rfc761}, has compounded the problems by encouraging browsers to allowing whitespace (\code{<scr ipt>}) or mixed-case (\code{<ScrIpT>}) when matching HTML tags.
The acceptance of tags formatted in unconventional manners contributes to the difficulty of identifying potentially malicious inputs.

\begin{table}[ht]
\centering
\begin{tabular}{l|ccccc}
 \textbf{Encoding Type} & \multicolumn{4}{c}{\textbf{Encoded variant of `\texttt{<}'}} \\
 \hline
 URL Encoding           & \texttt{\%3C} &&&\\
 HTML Entity            & \texttt{\&lt;} & \texttt{\&lt} & \texttt{\&LT;} & \texttt{\&LT} \\
 Decimal Encoding       & \texttt{\&\#60;} & \texttt{\&\#060;} & \texttt{\&\#0060;} & \texttt{\ldots} \\
 Hex Encoding           & \texttt{\&\#x3c;} & \texttt{\&\#x03c;} & \texttt{\&\#X3c} & \texttt{\ldots} \\
 Unicode                & \texttt{\textbackslash u003c} &&&\\
\end{tabular}
\caption[Submanifold]{Examples of Character Encoding~\cite{kals.etal+06}.}
\label{tab:html-encoding}
\end{table}

\subsection{Escaping}\label{sec:escaping}
Once an attacker succeeds in getting past any input filters, the issue of document structure still remains.
Web applications \code{quote} or \code{escape} user-supplied inputs with the intention of having such inputs presented in the page as plain text.
We give two such examples~\cite{xss-filter-input} of environment escaping.

\begin{description}
 \item[Escaping up the DOM hierarchy.] \hfill \\
    An attacker can inject code into the current domain by closing the current HTML tag environment and beginning a new script environment that contains the malicious payload.
    To exploit \autoref{list:escape-quote}, the attacker substitutes the \code{\%(query)} with the input string \code{blah"><script>evil\_script()</script>}.
    Assuming the literal, inlined inclusion of the input into the page, the attacker obtains the following result:

\lstset{
  label=list:escape-quote,
  caption={HTML code containing a quoted query parameter.}
}
\begin{exploit-example}
  <form>
    <input name=q value="\%(query)s">
  </form>
\end{exploit-example}

\lstset{
  label=list:escape-quote-exploit,
  caption={Query substitution that prematurely closes the \code{<input>} tag in \autoref{list:escape-quote}.}
}
\begin{exploit-example}
  <form>
    <input name=q value="blah"><script>evil_script()</script>">
  </form>
\end{exploit-example}

 Because the HTML parser executes before the JavaScript parser, the attacker could insert a \code{</script>} tag to escape a quoted string from within an existing script environment\footnote{Again, assuming literal, inlined inclusion of the input into the page.}.
Even when the input is sanitized so as to contain no HTML control characters, and thus prevent the inclusion of such tags, there may still be means of escaping the quoted environment via different encodings.
\term{Node splitting} attacks prematurely close tags in this manner.

 \item[Escaping down to a subcontext.] \hfill \\
   If the application does not protected the query via quoting, a different attack, known as an \term{attributed injection} attack can occur.
   To exploit \autoref{list:escape-noquote}, the attacker substitutes the \code{\%(query)} with the input string \code{blah onmouseover=evil\_script()}.
   Assuming the literal, inlined inclusion of the input into the page, the attacker obtains the following result:

\lstset{
  label=list:escape-noquote,
  caption={HTML code containing an un-quoted query parameter.}
}
\begin{exploit-example}
  <form>
    <input name=q value=\%(query)s>
  </form>
\end{exploit-example}

\lstset{
  label=list:escape-noquote-exploit,
  caption={Query substitution that adds an attribute on the \code{<input>} tag in \autoref{list:escape-noquote}.}
}
\begin{exploit-example}
  <form>
    <input name=q value=blah onmouseover=evil_script()>
  </form>
\end{exploit-example}

  The injection, in this case, occurs within the same HTML context.
  The attacker has the freedom to use other event handlers, such as \code{onload} that executes the script without need for user interaction.

\end{description}

In both these examples, the attacker can use the \code{javascript:} URL scheme, or many different textual encodings schemes to aid in bypassing the sanitization and input filtering routines.
In general, these sorts of issues, in combination with the vast number of inputs and outputs that require sanitization, make it practically impossible for web developers to track all such vulnerabilities in their applications.

\subsection{Script Identification}

Examples from RSnake's XSS Cheat Sheet~\cite{xsscheatsheet}\footnote{The XSS Cheat Sheet also provides a handy reference of malicious scripts that can be used to test user input filters.} exhibit many ways in which a script can be encoded to bypass user input filters.
As a second line of defense, a web page can employ syntax filters and program analysis to restrict the running of malicious scripts~\cite{reis.etal+06, yu.etal+07, yaowen.etal+04}.

Just as HTML has many different character encodings, JavaScript provides several syntaxes for accessing an object's properties.
For example, each of the three lines in \autoref{list:js-syntax} creates a dialog box with the contents of a page's cookie.

\lstset{
  label=list:js-syntax,
  caption={Alternative syntaxes in JavaScript for creating a dialog box.}
}
\begin{jscode}
alert(document.cookie)
alert(document['cookie'])
with(document) alert(cookie)
\end{jscode}

This multiplicity interferes with code routines that attempt to identify malicious code when filtering user input.
To provide a clear demonstration of difficulties encountered by input filtering, Hasegawa~\cite{xssfilters} manufactured the following JavaScript snippet that calls \code{alert(1)}, yet contains no alphanumeric characters\footnote{This code may not execute on a modern browser. JavaScript remains a moving target as browser vendors continually update and modify the access rules to built-in objects in response to exploited vulnerabilities.}:

\lstset{
  label=list:obfuscated-alert,
  caption={An obfuscated call to \code{alert(1)} provided by Hasegawa~\cite{xssfilters}.}
}
\begin{jscode}
($=[$=[]][(__=!$+$)[_=-~-~-~$]+(\{\}+$)[_/_]+($$=($_=!''+$)
[_/_]+$_[+$])])()[__[_/_]+__[_+~$]+$_[_]+$$](_/_)
\end{jscode}

\subsection{Mashups and Third-Party Scripts}\label{sec:mashups}

As the Web moves to a more service-oriented architecture, the ease with which web pages combine data from many disparate sources into a single interface has led to a renaissance in web application design.
The dynamic and flexible nature of asynchronous JavaScript and XML (AJAX) enables programmers without any security background to create a \term{web mashup} that links to and integrates content from existing web services, without stringently checked application programming interfaces.

For example, a calendar mashup can recognize street addresses and incorporate a miniature map next to the user's appointments.
The ability to share and distribute user data between services hosted by different web domains has security implications that are only now being discovered.
The architecture of a mashup unfortunately requires that it pulls together many scripts from different sources into a single browser process.
As a result, mashups have been referred to as a `self inflicted cross site scripting attack'~\cite{mashup}.

The concerns regarding mashups also apply to syndicated web advertisement that financially supports most of the interactive services available online today.
During syndication, web advertisement space gets sold and re-sold through several marketing companies, before finally being purchased by an online retailer.
A webpage with advertisement loads a script from the syndication server, which then loads another script from a dynamically chosen advertisement provider.
Because web advertisement involves JavaScript code that loads onto a page from a third-party server, web developers should consider it a security risk, as demonstrated by the RightMedia Trojan (Section~\ref{sec:advertisement}).

\section{Current Browser Security}\label{sec:current-security-models}

Many security researchers view the ability to automatically run arbitrary code downloaded from the Web as an inherent security risk.
JavaScript fortunately disallows access to the underlying file system on a client machine, making it \term{sandboxed} to the execution environment supplied by the browser.
Despite this restriction, JavaScript has a long history of security vulnerabilities resulting from its intricate interaction (through the DOM) with the large amount of sensitive user data controlled by the browser.
Historically, protecting user data has received much less attention than browser functionality and developer convenience.
%As issues regarding the privacy of user data began to surface, several security models have been added to the browsers' execution environment.

\subsection{Same Origin Policy}\label{sec:same-origin}

Web applications rely on the \term{Same Origin Policy} (SOP)~\cite{sop}, which has been in effect since the first version of JavaScript, as the primary mechanism to restrict unauthorized data flow.
The policy enforces the separation of scripts within the browser by assigning each script a tuple $\langle$domain name, protocol, port number$\rangle$, representing the origin of that script.
The browser then permits only scripts of the same origin to communicate and share data and prohibits other forms of inter-script communication (\autoref{tab:same-origin}).
The SOP mediates DOM access, cookie data, and \code{XMLHttpRequest}s.
Each of the three items in the domain tuple must match for the policy to consider two origins equivalent.

\begin{table}[ht]
\centering
\resizebox{\columnwidth}{!}{
\begin{tabular}{l|c|l}
\textbf{Compared URL} & \textbf{Outcome} & \textbf{Reason} \\
\hline
\multicolumn{3}{l}{\url{http://store.company.com/dir/page.html}} \\
\hline
\url{http://store.company.com/dir2/other.html} & Success & \\
\url{http://store.company.com/dir/inner/another.html} & Success &\\
\url{https://store.company.com/secure.html} & Failure & Different Protocol\\
\url{http://store.company.com:81/dir/etc.html} & Failure & Different Port\\
\url{http://news.company.com/dir/other.html} & Failure & Different Host\\
\url{http://company.com/dir/other.html} & Failure & Different Host\\
& & (exact match required)\\
\url{http://en.company.com/dir/other.html} & Failure & Different Host\\
 & & (exact match required)\\
\end{tabular}
}
\caption{Results of comparison to \url{http://store.company.com/dir/page.html} using the Same Origin Policy~\cite{sop}.}
\label{tab:same-origin}
\end{table}

Although it seems like a secure mechanism, the same-origin policy possesses significant drawbacks.
For example, two subdomains that wish to communicate must use a fully-qualified, right-hand suffix of their domain, which may permit access to more subdomains than the webpage creator desires.
Using this mechanism, a page from \code{news.example.com} can communicate with a page from \code{www.example.com} only if both pages set their \code{document.domain} to \code{example.com}.
But doing so also allows pages from \code{untrusted.example.com} potential access.
Furthermore, other communication side-channels still exist, allowing two pages of completely different domains to access each other's content by using shared server-side data or through the exploitation of browser bugs.

Restricting the access rights of JavaScript programs in this manner has met with mixed success.
Web authors sometimes view as either too draconian and inconvenient since it prevents accessing data useful or required by the application, while security researchers view it as ineffective since they can usually find a mechanism to bypass the restriction.

To the extent that it remains feasible to do so, web applications commonly employ the SOP as a first line of defense against XSS attacks.
Unfortunately, the policy often clashes with modern web application architecture, as web applications often include third-party libraries or services as part of a mashup.
Using the SOP to properly isolate third-party content requires using an inline frame (\code{iframe}).
The communication barriers that the SOP introduces between frames has even led to the development of techniques for message passing to and from the frame through side channels and a proposal for an built-in addition the web browser infrastructure for this special case~\cite{barth.etal+08}.
The SOP and its inconveniences serve as an example clashing between existing web browser security infrastructure and the features demanded by modern web applications.

\section{Summary}

Modern web applications pull their content and code from a wide variety of sources into a single page.
Servers deliver HTML layout, JSON and XML data, and JavaScript code as source text.
The different language specifications for character and token encoding makes filtering and identifying malicious code difficult.
XSS attacks can inject code onto the web application's servers, making code origin an unreliable indicator of trustworthiness.
These attacks pose a serious security risk for both customers and businesses.
Innocent users become victims merely by visiting an infected page.

