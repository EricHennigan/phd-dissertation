
\chapter{JavaScript Feature Catalog}

JavaScript, like many scripting languages, agglomerates different programming paradigms and provides a large number of built-in convenience functions.
In order to provide a comprehensive treatment of the labeling semantics and tracking provided by \FlowCore, this chapter gives examples and explanation of tracking in the covered JavaScript language features.

\section{Data Flow Tracking}

JavaScript offers some built-in data types such as Date, String, Array, and Object which programmers use to compose larger data structures.
For reasons of efficient implementation JavaScript breaks down these data types into two categories: primitives, which fit into a 64-bit machine integer (according to the encoding in Chapter~\ref{sec:existing-type-system}), and objects, which function as generic key-value hash tables stored in the garbage-collected heap.
As mentioned in Chapter~\ref{ch:system-design}, this breakdown affects \FlowCore's implementation of label attachment and propagation.

\subsection{Primitives}

\FlowCore\ follows the fat value approach explored in the discussion on system design (Chapter~\ref{sec:chosen-implementation}).
This approach directly tags all primitives within the virtual machine, providing the foundation on which to build the tagging propagation rules.

The JavaScript Specification~\cite{ecma} defines the following primitive types:
\begin{description}
  \item \textbf{\code{Null}}, contains the single value \code{null} that represents the absence of an object value.
  \item \textbf{\code{Undefined}}, contains the single value \code{undefined} that acts as a placeholder for declared variables that have not been assigned a value.
  \item \textbf{\code{Boolean}}, contains the two value instances \code{true} and \code{false}.
  \item \textbf{\code{Number}}, contains all possible numeric values (defined according to the 64-bit binary format IEEE 754~\cite{ieee754}), including the ``Not-a-Number'' (NaN) values, positive infinity, and negative infinity.
  \item \textbf{\code{String}}, contains all possible string values (defined as a finite ordered sequence of zero or more 16-bit unsigned integers).
\end{description}

WebKit's JavaScriptCore implementation adjusts the specification in some subtle ways.

First, it separates \code{Number}s into two different classes: 32-bit integers and IEEE 754 doubles, which includes the special values NaN, positive infinity, and negative infinity.
Internally, this separation allows for JavaScriptCore (and its Just-in-Time compiler) to distinguish between floating point and integer numerical data types so that the interpreter uses the appropriate machine arithmetic operations.

Second, each of the boolean types receives its own primitive encoding (Figure~\ref{fig:base-encoding}).
This decision speeds up the recognition of these primitive values, by providing a direct representation that avoids wrapper objects.

Third, despite the designation of strings as primitives in the JavaScript specification~\cite{ecma}, JavaScriptCore implements them as native objects, interning the string values.
Consequently, strings appear as object pointer values in the \code{JSValue} 64-bit encoding (Figure~\ref{fig:base-encoding}) that reference native String Objects.
Additionally, all String Objects have a prototype reference to the String Prototype object that carries all of the specification-defined methods available for strings.
Within the JavaScriptCore implementation, native String Objects always remain clearly distinguishable from user-defined objects, allowing the interpreter to treat strings according to the rules defined in the JavaScript specification~\cite{ecma}.

Finally, JavaScriptCore implements additional values not present within the specification:
\begin{description}
  \item \textbf{\code{empty}}, which represents holes within an array and designates uninitialized values.
  \item \textbf{\code{deleted}}, which appears in hash table code and designates an invalid GC cell.
  \item \textbf{\code{pointer}}, which provides references to objects, both native and user-constructed, stored within the garbage-collected heap.
\end{description}

Two of these values, \code{empty} and \code{deleted}, have bit patterns that distinguish them from each of the primitives defined in the JavaScript specification~\cite{ecma}.
Within JavaScriptCore, no valid \code{JSValue} has the bit pattern of all zeros (the \code{empty} value), nor does any object reside at that address.
The \code{deleted} value contains a bit pattern that violates the object alignment within the garbage-collected heap.
The specification-defined \code{null} and \code{undefined} values have non-zero integral representation that distinguish them from the internal \code{empty} and \code{deleted} values (Figure~\ref{fig:base-encoding}).

\FlowCore\ tags all of these primitive values, including the additional ones specific to JavaScriptCore's implementation, by extending the base representation, \code{JSValue}, with an additional 32-bits.
This design allows for \FlowCore\ to tag all representable values within the JavaScriptCore interpreter, regardless of its mapping back to the JavaScript specification.
The most evident side-effect of tagging primitive pointer values rather than extending objects with an internal label field implies that \FlowCore\ follows the reference semantics discussed in Chapter~\ref{sec:impacts-on-security-semantics}.
As a side-effect of tagging all representable values within the interpreter, \FlowCore\ sometimes evaluates operations using a more conservative label than necessary.
%For example, iteration over an array with holes proceeds to use labels attached to the hole values, in spite of the language specification claiming holes should be skipped over entirely.

\subsection{Variables}
\label{sec:variables}

Unlike many other languages, variables in JavaScript do not float around freely, but are tied to a current context object.
Within a called function, the activation record acts as the current context.
At the JavaScript console, the built-in global object acts as the current context.
And within WebKit's debugging console, the context defaults to the built-in window object.

Given that JavaScript stores all variables as properties on an object, the semantics for accessing variables in JavaScript is the same as for accessing properties of objects.
Listing~\ref{list:vardef} shows these semantics at the JavaScriptCore console, where the \code{this} keyword references the built-in global object that holds defined variables.

\lstset{caption={Variable definition and access at the JavaScript console},
        label={list:vardef}}
\begin{jscode}
js> var x = 7
undefined
js> this.x
7
\end{jscode}

In other contexts, such as within a function call, the JavaScript programmer may not have access to the object that stores declared variables (i.e. the activation record object).
For example, in Listing~\ref{list:funcdef}, the \code{this} keyword does not refer to the activation record object.
Rather, it refers to the object holding the method definition, i.e., the built-in global object.

\lstset{caption={Variable definition and access in a JavaScript function.},
        label={list:funcdef}}
\begin{jscode}
js> function foo() {
      var x = 7;
      print(this.x);
    }
undefined // result value returned from function definition

js> foo()
undefined // result of printing this.x
undefined // result value returned from function call
\end{jscode}

In spite of the syntax for accessing the current context object or members of the activation record, the mental model of variable storage as properties on some object remains consistent throughout the specification and JavaScriptCore's implementation.
Consequently, the labeling semantics for variable access follow that of property access on objects.

\subsection{Objects}

Unlike class-based languages such as C++ and Java, JavaScript supports the dynamic generation of objects.
Rather than defining the presence of fields at compile-time, the JavaScript programmer constructs empty objects and populates them with properties at runtime.
JavaScript replaces the strict hierarchical relationship between object classes with runtime prototypal inheritance.
Property access proceeds by first scanning the initial object for the requested property.
In the event that the property is absent, the lookup proceeds by recursively scanning each object in the prototype chain, following the internal \brackdbl{Prototype} property.

\subsubsection{Property Access}

Objects in JavaScript resemble hash tables, with property name-to-value bindings created, updated, and removed at runtime.
Three different syntaxes allow a programmer to access an object's properties\footnote{The presence of \code{eval} and \code{with}-blocks can the path of access by naming the current context object, but their presence does not change the syntax of access.}.
As shown in Listing~\ref{list:property-access-notation} the first form does not explicitly name the object being accessed, while in the other two forms a dot or square bracket follows the name of the target object.

\lstset{caption={Syntax for Property Access},
        label={list:property-access-notation}}
\begin{jscode}
key      // property access targeting the current context object
obj.key  // property access using dot notation
obj[key] // property access using bracket notation
\end{jscode}

In the first example of Listing~\ref{list:property-access-notation}, \FlowCore\ retrieves \code{key} from the current context object.
The lookup path may follow the internal \brackdbl{scope} chain for properties defined in an outer lexical scope.
The resulting value \code{key} carries a tag representing the union of all labels encountered on the reference path taken.

In the latter two examples of Listing~\ref{list:property-access-notation}, \FlowCore\ first retrieves \code{obj} from the current activation object, in the same manner that it retrieves \code{key} in the first example.
Recall that \FlowCore\ does not tag the object itself, but rather tags the pointers that reference the object.
The resulting object reference \code{obj} then carries a tag representing the union of all labels encountered on the reference path taken.

In the bracket form, the interpreter first coerces the \code{key} into a string via the internal \code{ToString} function.
This coercion happens for all accesses, including numerical indexing on an array.
Assuming that the \brackdbl{ToString} method has not been overridden by the programmer, the result of the coercion carries the same label as the given \code{key}, otherwise it carries the label of the returned result from the overloaded method call.
In contrast, the dot notation contains the \code{key} as an embedded code string (requiring no coercion) that carries the label of the code source.

Once the object instance \code{obj} has been retrieved and the \code{key} calculated, the interpreter performs a hash-table lookup on the properties of that object.
In the event that an object does not itself have a value associated with the requested \code{key}, the lookup proceeds recursively through objects in the prototype chain following \brackdbl{Prototype} references.
Figure~\ref{fig:prototype-chain} shows this access path for a generic property lookup.

\newcommand{\hashvalue}[2]{\textlangle \code{#1} \textbar\ \code{#2}\textrangle}
\newcommand{\hashbrackdbl}[2]{\textlangle \brackdbl{#1} \textbar\ \code{#2}\textrangle}
\begin{figure}[h!]
  \centering
\begin{tikzpicture}[
  cell/.style={text badly centered},
  cellpath/.style={draw=black, text badly centered}
  ]

  \node[] (lookup) at (-2cm,0cm) {};

  \matrix [draw=gray, matrix anchor=west, column sep=1.5cm] (object1) {
    & \node[cellpath] (proto1) {\hashbrackdbl{Prototype}{P}}; \\
    & \node[cell] {\vdots}; \\
    & \node[cell] {\hashvalue{value}{A}}; \\
    \node[draw=black] (table1) {}; & \node[cell] {\hashvalue{value}{B}}; \\
    & \node[cell] {\hashvalue{empty}{C}}; \\
    & \node[cell] {\hashvalue{value}{D}}; \\
    & \node[cell] {\vdots}; \\
  };
  \node[above, anchor=south west] at (object1.north west) {Object \code{obj}};

  \matrix [draw=gray, matrix anchor=west, column sep=1.5cm] at (7cm,0cm) (object2) {
    & \node[cell] (proto2) {\hashbrackdbl{Prototype}{Q}}; \\
    & \node[cell] {\vdots}; \\
    & \node[cell] {\hashvalue{value}{E}}; \\
    \node[draw=black] (table2) {}; & \node[cell] (value2B) {\hashvalue{empty}{F}}; \\
    & \node[cellpath] (valueG) {\hashvalue{valueK}{G}}; \\
    & \node[cell] {\hashvalue{empty}{H}}; \\
    & \node[cell] {\vdots}; \\
  };
  \node[above, anchor=south west] at (object2.north west) {Object \code{obj}'s Prototype};

  \node[] (prototerm) at ([xshift=3cm]proto2) {//};

  \draw[arrow] (lookup) -- node[above, sloped] {\hashvalue{obj}{O}} (table1.west);
  \draw[arrow] (table1.east) -- node[above, sloped] {\hashvalue{key}{K}} (proto1.west);
  \draw[arrow] (proto1.east) -- (table2.west);
  \draw[arrow] (table2.east) -- node[above, sloped] {\hashvalue{key}{K}} (valueG.west);
  \draw[arrow] (proto2.east) -- (prototerm);

\end{tikzpicture}
\caption{
    \label{fig:prototype-chain}
    Path of access for a property defined on an object's prototype.
    References and values follow \hashvalue{value}{label} notation.}
\end{figure}

\subsubsection{Labeling Semantics for Property Access}
As shown in Figure~\ref{fig:prototype-chain}, property access begins with two labeled items: the object \code{obj} carrying label \code{O} and the stringified property name \code{key} carries label \code{K}.
The target value \code{valueK} ultimately found via the lookup chain also carries its own label \code{G}.
At minimum, the final label on the value resulting from the lookup incorporates labels from the starting object, the key, and the value found.
However, the lookup chain also involves labeled prototype references, so the label of the resulting value should incorporate the label of each object reference walked in the chain.
Additionally, tracking of direct implicit flows demands in joining the label of the current program counter to incorporate the current security context (Chapter~\ref{sec:control-flow-stack}).

In summary, the resulting value carries a label formed by the union of
\begin{itemize}
  \item the label of each reference link taken to look up the object,
  \item the label of the stringified key,
  \item the label of each prototype link taken to look up the value,
  \item the label of the value found (or bottom if no value present),
  \item and the label of the current program counter.
\end{itemize}

Note that, as a side-effect of joining in the label of each prototype reference along the lookup path, the \code{undefined} value that results from lookup of a non-existent property might have a label very high in the security lattice.
Consequently, we identify flagrant use of values taken from extended reference chains (explicit via syntax or implicit via lookup rules) yet another source of label creep in a JavaScript program.

As a prototype implementation of information flow, \FlowCore\ did not modify all of JavaScriptCore's internal helper methods to join in each component label.
Instead \FlowCore\ takes only label of the target (post-lookup) value under operation and the label of the current program counter.
This omission accomplishes several goals simultaneously.
It simplifies implementation, omits a source of label creep, improves runtime performance by eliding label joins, and permits a prototype implementation in WebKit's JIT (Chapter~\ref{sec:jitflow}).
A literature search did not reveal any other research work claiming to have implemented full prototype-chain labeling semantics. % with enough detail to retain believability.

\subsection{Functions}

The JavaScript specification~\cite{ecma} describes functions as having first-class status: they can be passed as arguments to other functions, returned as values from function calls, assigned to variables, and stored in data structures.
Additionally, functions in JavaScript do not require programmatic names and can be declared anonymous.

JavaScript does not feature the compiler-enforced access and visibility rules of class-based languages exemplified by the \code{public}, \code{private}, and \code{protected} keywords of C++ and Java.
Instead, JavaScript programs make widespread use of closures to achieve code encapsulation and data-hiding.
The JavaScriptCore interpreter supports this feature by separating the function code from an execution context, composed of three parts~\cite{ecma}:
\begin{itemize}
  \item the LexicalEnvironment, used to resolve identifier references made by code within the execution context,
  \item the VariableEnviornment, used to identify the context object that holds bindings created by variable statements and function declarations within the execution context,
  \item and the ThisBinding, used to provide the object targeted by the \code{this} keyword within the execution context.
\end{itemize}
Unlike the current context object (the target of the ThisBinding) described in Section~\ref{sec:variables}, the execution context remains inaccessible by any JavaScript program.

Just as \FlowCore\ labels values and object references, it also labels references to functions, supporting the first-class definitions offered by JavaScript.
At the cite of storage, the label of a function depends on how it gets defined.
Functions defined by loading source code have a label representing the domain from which the code was fetched.
Functions defined during runtime execution carry the label of the current program counter at the cite of definition.
When accessing a function in order to invoke a call, the label of function reference follows the same rules as provided earlier for the lookup of values (Section~\ref{sec:variables}).

The practice of using closures for data encapsulation and variable hiding does not affect the implementation of \FlowCore.
Instead, it only affects the storage placement of the function and consequently the path of access a programmer uses to retrieve the function for invocation.
Section~\ref{sec:function-calls} discusses the setup of the execution context prior to function evaluation and the mechanism for labeling the value resulting from the function call.

\subsection{Built-ins}

The JavaScript specification~\cite{ecma} provides numerous built-in functions and values, defined on the built-in Global Object.
Some of these built-ins have attributes that behave in a way that cannot be emulated in pure JavaScript, such as the \code{length} property of an \code{Array} object.

\FlowCore\ provides an initial bottom label for the constructor of each of these items but does not rewrite the internal functionality for label propagation.
Nor does \FlowCore\ provide special-case considerations for special attributes and methods for the built-in classes.
Rather, the implementation acquires label propagation ability through modifications made to the base \code{JSValue} datatype.

All programs, including malicious ones, retain the ability to override the built-ins by simply replacing that property on the Global Object.
For example, a running program may replace the built-in values \code{undefined} and \code{NaN} with its own definitions.
However, because of its construction at runtime, the new item carries a label dependent on the execution context, which necessarily differs from the bottom label assigned at start-up.
The presence of this label affects all later uses of the overridden item within the program.
In this manner, \FlowCore\ tracks the influence that an unexpected override may have on the rest of a JavaScript program, providing a mechanism to detect and track the influence of a malicious hijacking.

Although the implementation of \FlowCore\ does not cover every aspect of the JavaScript specification, the parts remaining are of only a practical concern.
This dissertation focuses on the implementation of a labeling framework that would support such effort and on the ramifications of attaching labels to values in a dynamic language.

\subsection{Expressions}

JavaScript, like any other computer language, supports the ability to create new values through the composition of existing values.
For example, a new numerical value, \code{x}, can be derived from the sum of two other values, \code{a} and \code{b}.

\lstset{caption={Value composition},
        label={list:value-composition}}
\begin{jscode}
var x = a + b;
// labelof(x) === label.join(labelof(a), labelof(b), labelof(pc))
\end{jscode}

An expression's resulting value depends not only on the input values, but also on the current execution context.
As a consequence of direct data-dependence in expressions, \FlowCore\ labels the result value using the join of all labels of values together with the label of the program counter.

To accomplish this task, we edited the C++ implementation of many of the operators within the JavaScriptCore interpreter to explicitly pull off the labels and perform the join as part of the computation.
Fortunately, the syntactically recursive nature of JavaScript expressions and the virtual register-machine based implementation of JavaScriptCore, permits updating each operator independently and rely on the compositional nature of the language for propagation.

As a prototype implementation, \FlowCore\ handles:
\begin{description}
  \item[Unary Math:] pre-increment, pre-decrement, post-increment, post-decrement, unary minus, and unary plus.
  \item[Binary Math:] addition, subtraction, multiplication, and division, string concatenation
  \item[Comparison:] equality, inequality, strict equality, strict inequality, less than, less than or equal to, greater than, and greater than or equal to, each for both numbers and strings.
  \item[Bitwise Operators:] shift left, shift right, shift right with zero fill, and, or, xor, and not.
\end{description}

Although the idea behind dataflow tracking through expression seems simple, \FlowCore\ derives much of its tracking capabilities through this feature.
After all, data structures comprise half of what makes a program\cite{wirth+76}.

\section{Control Flow}

Dynamically typed languages, such as JavaScript, present difficulties for tracking information dependence through control flow.
Although the automatic type coercion of values can be handled via dataflow mechanisms, the ability to dynamically dispatch on runtime input, the presence of first-class functions, and the presence of \code{eval} all conspire to increase the difficulty and decrease the scope of statically performed control flow analysis.
Consequently, \FlowCore\ undertakes only enough static control-flow analysis to instrument additional instructions (\autoref{ch:instructions}) that assist in performing label propagation during program execution.

Fortunately, JavaScript uses structured control flow constructs.
This language feature permits the use of a static analysis that calculates exactly at which point the information flow instructions introduced in \autoref{ch:instructions} need insertion into a program's instruction stream.

\FlowCore\ modifies the instruction generator of JavaScriptCore to instrument security instructions at parse time.
This modification allows \FlowCore\ to prevent certain categories of control-flow based information leaks (\autoref{sec:tracking-capabilities}) by using a control flow stack that tracks the security label of the program counter (\autoref{sec:control-flow-stack}) at runtime.

%This section presents a high-level motivation followed by the information flow instruction instrumentation for each type of control flow construct offered by JavaScript.

\subsection{Conditional Branches}

The conditional branch and the jump instructions that implement it, forms the foundation of many of the control flow constructs offered in JavaScript.

As exhibited by \autoref{list:2branch}, a conditional branch consists of three parts:
\begin{description}
  \item [The predicate.] \hfill \\
    A boolean that determines which branch to execute.
  \item [The true-branch.] \hfill \\
    A block of code that executes when the conditional evaluates True.
  \item [The false-branch.] \hfill \\
    An optional block of code that executes when the conditional evaluates False.
\end{description}

\lstset{caption={Example conditional branch.},
        label=list:2branch}
\begin{jscode}
    if (cond) {      // the predicate
        x = 233;     // the true-branch
    } else {
        y = 377;     // the false-branch
    }
\end{jscode}

\begin{figure}[h]
\begin{python}
code = r'''
function mybranch() {
  var cond;
  var x;
  var y;
  if (cond) {
    x = 233;
  } else {
    y = 377;
  }
}

print(debug(mybranch))
'''
import sys
sys.path.append('..')

import jsc
j = jsc.jsc(code)
j.run()

import bytecodeformatter
bytecodeformatter.tikz_picture(j.instructions())
\end{python}
  \caption{\FlowCore\ instruction stream represting the code snippet in \autoref{list:2branch}.}
  \label{fig:2branch-bytecode}
\end{figure}

Ordinary label propagation through straight-line code ensures that the predicate has an attached label.
\FlowCore\ uses this label to upgrade the label on the program counter and then pushes the new pc-label on the control flow stack, marking the entrance of a new program region that corresponds to the taken branch.



Conditional branches begin with a \texttt{DUP\_CFLABEL} instruction that marks the beginning of a secure code region by cloning the current pc-label.
The conditional value itself may be the result of an arbitrary expression, which could include function calls and shortcut evaluation of logical operators.
Consequently, its label is not predictable at compile time, so we emit a \texttt{JOIN\_CFLABEL} instruction immediately following the conditional evaluation.
This instruction upgrades the top of the control flow stack using the label of the conditional value computed at runtime.
When either side of the conditional branch finishes executing, a \texttt{POP\_CFLABEL} instruction at the control flow join restores the pc-label to its state before the branch was encountered.

\subsection{Function Calls}

- begin with dup\_cflabel
- end popping scope with popj\_cflabel
- return value is tainted, though not necessarily with the union of all arguments (depend on their use)

from this point forward, all of the following example bytecode dumps are encapsulated in their own function




\subsection{Function Calls}

JavaScript supports first-class functions, meaning that, just like Objects, references to functions carry a label.
Upon entry into a function, the VM joins the caller's current program counter label with the function reference label to set the callee's current program counter label.
All operations within the function occur under the new program counter label.

Entry into a function creates an \term{execution context}\cite{ecma}, beginning with an activation object that holds the function-local variables and an \code{arguments} object that gives array-like indexable access to the function's runtime arguments and caller.

\begin{comment}
function foo() {
  console.log(arguments.caller)        // undefined
  console.log(arguments.length)        // length of the argumets
  console.log(Function.caller)         // null
  console.log(foo.caller)              // code of parent function
  console.log(arguments.callee.caller) // code of parent function
  console.log(arguments.callee)        // code of self
  console.log(typeof arguments)        // object
}

foo(1,2,3,4)
\end{comment}


During execution, the \FlowCore\ applies the current program counter label to the result of all operations, including storage of function-local variables stored in the current activation object.
In particular, this labeling applies to implicitly defined local values such as the function's return value, the \code{arguments} object, and any raised exception objects.
Additionally, the labeling applies to any variables accessed along the \brackdbl{scope} chain, using the same procedures for variable access on the \brackdbl{property} chain.

\subsubsection{Closures}

Because JavaScript doesn't support the \code{public}, \code{private}, and \code{protected} access modifiers of class-based languages, programmers use closures for state encapsulation.

\url{http://jibbering.com/faq/notes/closures/#clScCh}


When the VM executes a function, the label on the reference used to make the call is used as the initial program counter label upon entry into the function.

it's too early to provide code samples of the labeling
  have to introduce both the attached label syntax
  and the first-class labeling framework
instead we have to talk specifically about semantics
  breaks up into two parts
  1. calling and return value
  2. local variables

what to say about closures ?


JavaScript supports first-class functions, meaning that references to functions carry a label.
In addition to the principals joined during computation, the label on the value returned from a function also includes all principals in label on the reference used to make the call.

\lstset{caption={Label of Function Return Depends on Label of Reference to the Function}
        label={list:label-function-reference}}
\begin{jscode}
\end{jscode}

todo: describe what happens on entry
todo: describe what happens on return
todo: show where the bytecodes get placed for 

When calling a function, the label on the program counter at the site of the call joins with 

JavaScripts offering of first-class functions means that \FlowCore\
Source code definining function
\FlowCore\ labels source code with the domain of origin, providing a label on the LexicalEnvironment.
When the interpreter

\begin{enumerate}
 \item [The function is provided by a script.]
  When the host environment hands a script to the JavaScript VM, it has the option of labeling that script with a security principal.
  In this case, the function lookup process is responsible for retrieving the label of the function.
 \item [The function is an uncloaked first class value.]
  The current program counter implicitly labels anonymous functions at the time of their creation.
  As a result, the label of the function is always lower than that of the pc-label, and it is safe to call directly.
 \item [The function is a cloaked first class value.]
  If a sensitive control flow computation resulted in the return of a function, the return specification (see Section~\ref{sec:returns}) cloaks the function.
  In this case, the VM retrieves label of the function from its wrapper before the call.
\end{enumerate}

http://lostechies.com/derekgreer/2012/02/17/javascript-closures-explained/
http://javascript.info/tutorial/closures




\subsubsection{Closures}
\subsection{Early Return}
\subsection{Break and Continue}
\subsection{Exceptions}
\subsection{Eval}
property access and creation

\subsection{With}
property access and creation


 - what to do with arrays, or does this fit better in design considerations?
   : Can coalesce labels on arrays?
   : label bounds checking? 
 - obj literals
   how they interact with obj poisoning attack
 - retrieval
   indexing syntax [] vs .
   prototype chain
 - Seth Just Information flow analysis for JS has a good discussion about control flow structures.
 - early returns (out of nested loops)
 - break/continue (in nested loops)

%%%%%%%%%%%%%%%%%%%%%%%%%
% From 2011 acsac.tex

DONE Although dynamically typed languages present many difficulties for ensuring information flow, we find that JavaScript uses structured control flow constructs.
DONE As a result, we can use a static analysis which calculates exactly at which points our security instructions should be inserted into the instruction stream.
DONE This modification allows our system to prevent implicit information flow leaks by tracking the security label of the program counter at runtime, using the control flow stack.
DONE %Because local variables cannot leak information, allowing them to automatically upgrade still complies with the intention of non-interference security~\cite{goguen1982security}.
DONE %Variables which can leak information are subject to the \textit{no sensitive upgrade} check (see Section~\ref{sec:sensitive-upgrade-check}), and are prevented from automatic upgrade.
DONE %Using these principles, we demonstrate the labeling strategy for several control flow structures defined in the JavaScript language~\cite{ecma}.

\subsection{Conditional Branches}
\subsection{Loops}

Because of the implied backwards branch, loops require more care than conditional branches.
Prior to entering the loop a \texttt{DUP\_CFLABEL} instruction clones the current pc-label.

Again, because the condition is a runtime evaluated expression, only a dynamic analysis can identify the correct label to apply to the loop body.
The possibility of an earlier iteration influencing a later iteration complicates the situation.
Our implementation emits a \texttt{JOIN\_CFLABEL} instruction at the end of the conditional, despite the fact that this forces the current pc-label to be re-upgraded at each iteration.
Upon exiting the loop, a \texttt{POPJ\_CFLABEL} instruction restores the pc-label to its state before the loop was encountered.

One caveat of this solution is that it allows a monotonically increasing label on the loop body.
It is unfortunately possible that later iterations may carry a higher pc-label than earlier iterations, even when these iterations do not influence each other.
For example, an array might contain a sequence of completely unrelated values, each cloaked with a different security label.
When looping over such a construction, our implementation does not downgrade the loop context, even if independence of iterations could be proven.

\subsection{Break and Continue}
\label{sec:break-and-continue}
JavaScript allows the \texttt{break} and \texttt{continue} statements to specify which loop they apply to.
This complicates the maintenance of a control flow stack, because such statements may jump out of an arbitrarily nested loop.
Such jumps can bypass the normal exit criteria of nested loops, thereby causing the control flow stack to be out of alignment at the target location.
To maintain correct runtime-behavior we must handle this issue by ensuring that the instruction emitter generates the correct number of control flow pops for any nested loops that are exited.
A static analysis in the parser performs this computation and provides the resulting number as a parameter to the \texttt{POPJ\_CFLABEL} instruction.

Loop index variables, which are commonly bound to the function scope\footnote{JavaScript binds variables declared with \texttt{var} to the function scope, and did not have a block level scope prior to the introduction of \texttt{let} in version~1.7.} can be used for an implicit information leak if they are not all upgraded to the current pc-label at the time a \texttt{break} or \texttt{continue} statement is encountered.
Our system prevents potential implicit information leaks by emitting a \texttt{POPJ\_CFLABEL} instruction that not only pops the correct number of control flow labels, but also takes care to upgrade the control flow stack for the current function.
Upgrading the control flow stack in this manner upgrades all the values present on the operand stack at the time the interruption in control flow occurred.
Any later computations performed by the function are then considered to be influenced by the security context in effect at the time the \texttt{break} or \texttt{continue} statement was encountered.

\subsection{Exceptions}
\label{sec:exceptions}
Exceptions represent a substantial challenge to information flow security, because a \texttt{throw} permits any called function to create an early return that crosses multiple function boundaries.
To complicate security issues further, JavaScript supports the \texttt{try}, \texttt{catch}, \texttt{finally} triplet of keywords.

The exception handling region of the \texttt{try}-block begins with a \texttt{DUP\_CFLABEL} instruction.
As a conservative precaution, when the interpreter encounters a \texttt{throw} statement, it takes care to first cloak the exception object that is to be returned to the exception handler using the current pc-label.
Once the interpreter finds the appropriate handler, it pops all activation frames within the call chain.
Control flow then transfers to the corresponding \texttt{catch}-block where a \texttt{POPJ\_CFLABEL} instruction upgrades the entire control flow stack of the handling function using the label taken from the exception object.
Taking this action prevents implicit information leaks that might occur due to exiting the \texttt{try}-block early.
Such leaks are analogous to the \texttt{break} and \texttt{continue} (see Section~\ref{sec:break-and-continue}).

The \texttt{finally}-block always executes using the current pc-label, which is provided either by finishing the \texttt{try}-block or from catching an exception and executing the \texttt{catch}-block.

\subsection{Function calls}
\label{sec:function-calls}
We found it unnecessary to introduce additional instructions to handle function calls.
Instead, we instrument the existing routine for a function call to lookup the label of a function at call time.
When a function call occurs, our system first duplicates the top of control flow stack then joins it with the label of that function.
This action makes all operations which occur within the body of that function safe.
The location of this label breaks down into three cases:
\begin{description}
 \item [The function is provided by a script.]
  When the host environment hands a script to the JavaScript VM, it has the option of labeling that script with a security principal.
  In this case, the function lookup process is responsible for retrieving the label of the function.
 \item [The function is an uncloaked first class value.]
  The current program counter implicitly labels anonymous functions at the time of their creation.
  As a result, the label of the function is always lower than that of the pc-label, and it is safe to call directly.
 \item [The function is a cloaked first class value.]
  If a sensitive control flow computation resulted in the return of a function, the return specification (see Section~\ref{sec:returns}) cloaks the function.
  In this case, the VM retrieves label of the function from its wrapper before the call.
\end{description}

\subsection{Returns}
\label{sec:returns}
A returned value needs to carry information indicating the security context under which the value was produced.
Our system achieves this by explicitly cloaking the return value with the current pc-label using \texttt{CLOAK} instruction.
%\todo{more? if value is already cloaked...}

\subsection{Eval}
\label{sec:eval}
Our system treats \texttt{eval} similar to other function calls.
In this case, the parameter string passed into the \texttt{eval} provides the label for the new execution context.
A call to \texttt{eval} first compiles this string into an instruction stream.
As a result of passing through the parser, this stream contains all of the security instructions as would a normal script.

%The \texttt{eval} frame performs variable access using dynamic lookup.
%The bytecodes emitted for these lookups are the same as the bytecodes emitted for a parent lexical scope (equiv. to global) accesses.
%Our system already mediates the modification of such variables using the \textit{no sensitive upgrade} check (see Section~\ref{sec:sensitive-upgrade-check}), so no extra precautions are necessary for securing the \texttt{eval} construct.

%===============================================================================

\section{Evaluation}
\label{sec:evaluation}

%
%To evaluate our claims we modified SpiderMonkey, the JavaScript VM used in the Mozilla Firefox browser.
%We examine the bytecode overhead introduced by the inclusion of the secure bytecodes, as well as its affect on usability.
%Based on our results from browsing real websites, we give some insight into the architectural changes website authors might have to make to support information flow security.

Our implementation focuses mainly on the creation of a fully functional and correct information flow tracking system.
We would like to note that, to the best of our knowledge, no standard set of tests for information flow frameworks currently exists.
Given this situation, we use the SunSpider~\cite{sunspider} benchmark suite to assess the overhead which our framework introduces.
Despite the fact that it does not faithfully represent real-world JavaScript~\cite{jsmeter}, we choose this suite because its status as the standard benchmark suite for JavaScript makes it suitable for comparisons to other work.

\subsection{Growth of Instruction Stream}
%\begin{figure*}[ht]
%  \centerline{\includegraphics[width=18cm,keepaspectratio=true]{graphics/evaluation_bytecodes.pdf}}
%  \caption{Bytecodes emitted for SunSpider benchmark}
%  \label{fig:eval_bytecodes}
%\end{figure*}

%Figure~\ref{fig:eval_bytecodes} shows the number of emitted bytecodes for each test in the SunSpider benchmark.

To examine impact that introducing the new security instructions has on the memory requirements of SpiderMonkey's internal bytecode representation, we measure the change in size of the emitted instruction stream, for each test in the SunSpider~0.9.1 benchmark suite.
Despite the fact that SunSpider runs only with only a single security principal, we find it useful for measuring the overhead incurred by introducing additional security instructions to well-known algorithms.

% secure = [178, 15, 158, 25, 48, 38, 25, 8, 14, 3, 20, 29, 181, 71, 87, 140, 183, 18, 6, 28, 4, 36, 32, 129, 83, 32]
% total = [ 2238, 173, 2446, 213, 334, 668, 164, 94, 81, 26, 167, 154, 2957, 1753, 930, 1313, 1556, 238, 195, 278, 144, 794, 325, 569, 592, 360]
% data = zip(secure, total)
% d = [ float(x[0]) / (x[1] - x[0]) for x in data ]
% d[8], d[11], d[23], (sum(d)/len(d))
We observe that tests such as \textit{string-tagcloud}, \textit{bitops-bit-in-byte} and \textit{controlflow-recursive}, which contain very ``branchy'' code with respect to their short length, incur the highest overhead; 29.3\%, 21.0\%, and 23.2\% respectively.
Control flow constructs feature much less prominently in the other SunSpider tests, so the introduction of instructions which track branches and merges incur a much lower overhead.
Inserting our security instructions into the instruction stream never causes it to grow by more than 30\%, and maintains an average overhead of 11.6\% growth.

We therefore feel it important to note that many optimization opportunities for reducing the overhead of our techniques remain available for future work.
For example, the overhead of introducing these instructions can likely be optimized away by using a runtime analysis to type-specialize over the labels on arguments and functions.
%Such techniques are very common among interpreter-based virtual machines to optimize ordinary operations.
%For the future however, we plan to follow the quickening approach so that our framework starts executing a bytecode-stream that includes the secure instructions and can jump to an unmodified bytecode-stream whenever possible.

\subsection{Effect on Performance}
\label{sec:evaluation-performance}

We executed the SunSpider~0.9.1 benchmark suite on a Quad Core Intel Xeon~5140 running at 2.33~GHz with 32GiB~RAM running Linux kernel~2.6.3.2.
To achieve a stable basis of comparison, we execute each test in the suite 100 times, and take the average over all runs.

Our modified version of SpiderMonkey requires 140 seconds to execute the entire benchmark, while an unmodified version requires only 22.5 seconds.
We compile both versions using the same flags.
This test demonstrates an overhead of approximately 6x, primarily due to the introduction of explicitly cloaked values at return sites.

Since each cloak is itself a JavaScript object, our system generates a much larger number of objects than an unmodified system, and thus spends more time doing object allocation and garbage collection.
Currently, SpiderMonkey uses an unsophisticated mark-and-sweep garbage collector and does not employ generational collection.
Recent improvements to the garbage collector~\cite{wagner2011} have already demonstrated a remarkable increase in collection speed, which will likely benefit our implementation.
We also believe that we can reduce the number of cloak objects and improve our implementation by using techniques such as sparse labeling~\cite{1554353,1814220}.
%Specifically, we expect to see a large performance improvement by placing objects into a labeled compartment within the garbage collector.

%We also visited several websites, to evaluate this performance overhead as it would appear to a casual user.
%When browsing the web with our system, we did not notice any slowdown for ordinary pages.
%However, we did notice a slight response delay when interacting with JavaScript heavy applications (such as GMail).

\subsection{Violations Issued when Browsing the Web}
We implement enough of the security framework that we can compile and run the Firefox browser.
Although we modify the SpiderMonkey interpreter to track information flow, we found that Firefox uses JavaScript internally for a large number of subsystems (including the user interface).
Despite the potential for covert channels, we chose to whitelist the classes involved in these subsystems and consider them a portion of the trusted code base.


We also used our modified version of Firefox to visit the top 10 sites in the \textit{Alexa's Top Sites}~\cite{alexa} listing.
During this test, our system detects a large number of information flow violations.
Figure~\ref{fig:eval_falsepositives} highlights the total number of unique violations issued for each of these pages.
Manual investigation reveals that the vast majority of these sites load images and other resources from a separate server.
Because sites request these resources from a domain different than the site itself, our system triggers an alarm due to the interaction of DOM objects having separate labels.
For our approach to be adopted in a working environment, web site authors clearly need a policy specification framework (further discussed in Section~\ref{sec:policy_specification}), so that they can express their site's trust in a content distribution server.

\todo[inline]{Figure of false positives}
\begin{comment}
\begin{figure}[htp]
  \centerline{\includegraphics[width=12cm,keepaspectratio=true]{graphics/evaluation_falsepositives.pdf}}
  \caption{Information flow alarms triggered when browsing Alexa's Top Sites in the United States~\cite{alexa}.}
  \label{fig:eval_falsepositives}
\end{figure}
\end{comment}

\subsection{Verification}

In addition to the evaluations presented above, we also implement 173 private test cases to ensure that we generate the correct labels for each of the control flow structures mentioned in Section~\ref{sec:program-control-structures}.
Our system is correctly able to identify both explicit and implicit information flows represented in this test suite, including the two examples presented in Figure~\ref{fig:threat_if} and Figure~\ref{fig:threat_for}.
Although this effort does not substitute for a proof of correctness, it does give us confidence that our implementation faithfully follows the approach we have outlined.

Our system also runs an abstract interpreter that verifies the control flow stack height at every instruction of a method.
This analysis covers \emph{all} possible executions paths for every method parsed, and ensures that we never introduce security instructions that might cause a runtime misalignment of the control flow stack.
We are able to run this verification over all of the more than 2,000 tests in the SpiderMonkey testing suite, which Mozilla uses to detect regressions for every code change.

%\todo{address reviewer comment: Performance overhead is reasonable, some benchmarks using real-world applications would be useful to estimate the actual impact on a system}

%===============================================================================


\todo[inline]{pull citations from acsac-tr}

\todo[inline]{remove the word 'bytecode' and 'opcode', replace with instruction}
\todo[inline]{remove security instruction, replace with control flow instruction}
