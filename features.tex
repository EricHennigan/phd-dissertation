
\chapter{Label Tracking in JavaScript}
\label{ch:label-tracking}

JavaScript, like many scripting languages, agglomerates different programming paradigms and provides a large number of built-in convenience functions.
In order to provide a comprehensive treatment of the labeling semantics and tracking provided by \FlowCore, this chapter gives examples and explanation of tracking in the covered JavaScript language features.

\section{Data Flow Tracking}
\label{sec:data-flow-tracking}

JavaScript offers some built-in data types such as Date, String, Array, and Object which programmers use to compose larger data structures.
For reasons of efficient implementation JavaScript breaks down these data types into two categories: primitives, which fit into a 64-bit machine integer (according to the encoding in \autoref{sec:existing-type-system}), and objects, which function as generic key-value hash tables stored in the garbage-collected heap.
As mentioned in \autoref{ch:system-design}, this breakdown affects \FlowCore's implementation of label attachment and propagation.

\subsection{Primitives}

\FlowCore\ follows the fat value approach explored in the discussion on system design (\autoref{sec:chosen-implementation}).
This approach directly tags all primitives within the virtual machine, providing the foundation on which to build the tagging propagation rules.

The JavaScript Specification~\cite{ecma} defines the following primitive types:
\begin{description}
  \item \textbf{\code{Null}}, contains the single value \code{null} that represents the absence of an object value.
  \item \textbf{\code{Undefined}}, contains the single value \code{undefined} that acts as a placeholder for declared variables that have not been assigned a value.
  \item \textbf{\code{Boolean}}, contains the two value instances \code{true} and \code{false}.
  \item \textbf{\code{Number}}, contains all possible numeric values (defined according to the 64-bit binary format IEEE 754~\cite{ieee754}), including the ``Not-a-Number'' (NaN) values, positive infinity, and negative infinity.
  \item \textbf{\code{String}}, contains all possible string values (defined as a finite ordered sequence of zero or more 16-bit unsigned integers).
\end{description}

WebKit's JavaScriptCore implementation adjusts the specification in some subtle ways.

First, it separates \code{Number}s into two different classes: 32-bit integers and IEEE 754 doubles, which includes the special values NaN, positive infinity, and negative infinity.
Internally, this separation allows for JavaScriptCore (and its Just-in-Time compiler) to distinguish between floating point and integer numerical data types so that the interpreter uses the appropriate machine arithmetic operations.

Second, each of the boolean types receives its own primitive encoding (\autoref{fig:base-encoding}).
This decision speeds up the recognition of these primitive values, by providing a direct representation that avoids wrapper objects.

Third, despite the designation of strings as primitives in the JavaScript specification~\cite{ecma}, JavaScriptCore implements them as native objects, interning the string values.
Consequently, strings appear as object pointer values in the \code{JSValue} 64-bit encoding (\autoref{fig:base-encoding}) that reference native String Objects.
Additionally, all String Objects have a prototype reference to the String Prototype object that carries all of the specification-defined methods available for strings.
Within the JavaScriptCore implementation, native String Objects always remain clearly distinguishable from user-defined objects, allowing the interpreter to treat strings according to the rules defined in the JavaScript specification~\cite{ecma}.

Finally, JavaScriptCore implements additional values not present within the specification:
\begin{description}
  \item \textbf{\code{empty}}, which represents holes within an array and designates uninitialized values.
  \item \textbf{\code{deleted}}, which appears in hash table code and designates an invalid GC cell.
  \item \textbf{\code{pointer}}, which provides references to objects, both native and user-constructed, stored within the garbage-collected heap.
\end{description}

Two of these values, \code{empty} and \code{deleted}, have bit patterns that distinguish them from each of the primitives defined in the JavaScript specification~\cite{ecma}.
Within JavaScriptCore, no valid \code{JSValue} has the bit pattern of all zeros (the \code{empty} value), nor does any object reside at that address.
The \code{deleted} value contains a bit pattern that violates the object alignment within the garbage-collected heap.
The specification-defined \code{null} and \code{undefined} values have non-zero integral representation that distinguish them from the internal \code{empty} and \code{deleted} values (\autoref{fig:base-encoding}).

\FlowCore\ tags all of these primitive values, including the additional ones specific to JavaScriptCore's implementation, by extending the base representation, \code{JSValue}, with an additional 32-bits.
This design allows for \FlowCore\ to tag all representable values within the JavaScriptCore interpreter, regardless of its mapping back to the JavaScript specification.
The most evident side-effect of tagging primitive pointer values rather than extending objects with an internal label field implies that \FlowCore\ follows the reference semantics discussed in \autoref{sec:impacts-on-security-semantics}.
As a side-effect of tagging all representable values within the interpreter, \FlowCore\ sometimes evaluates operations using a more conservative label than necessary.
%For example, iteration over an array with holes proceeds to use labels attached to the hole values, in spite of the language specification claiming holes should be skipped over entirely.

\subsection{Variables}
\label{sec:variables}

Unlike many other languages, variables in JavaScript do not float around freely, but are tied to a current context object.
Within a called function, the activation record acts as the current context.
At the JavaScript console, the built-in global object acts as the current context.
And within WebKit's debugging console, the context defaults to the built-in window object.

Given that JavaScript stores all variables as properties on an object, the semantics for accessing variables in JavaScript is the same as for accessing properties of objects.
\autoref{list:vardef} shows these semantics at the JavaScriptCore console, where the \code{this} keyword references the built-in global object that holds defined variables.

\lstset{caption={Variable definition and access at the JavaScript console},
        label={list:vardef}}
\begin{jscode}
js> var x = 7
undefined
js> this.x
7
\end{jscode}

In other contexts, such as within a function call, the JavaScript programmer may not have access to the object that stores declared variables (i.e. the activation record object).
For example, in \autoref{list:funcdef}, the \code{this} keyword does not refer to the activation record object.
Rather, it refers to the object holding the method definition, i.e., the built-in global object.

\lstset{caption={Variable definition and access in a JavaScript function.},
        label={list:funcdef}}
\begin{jscode}
js> function foo() {
      var x = 7;
      print(this.x);
    }
undefined // result value returned from function definition

js> foo()
undefined // result of printing this.x
undefined // result value returned from function call
\end{jscode}

In spite of the syntax for accessing the current context object or members of the activation record, the mental model of variable storage as properties on some object remains consistent throughout the specification and JavaScriptCore's implementation.
Consequently, the labeling semantics for variable access follow that of property access on objects.

\subsection{Objects}

Unlike class-based languages such as C++ and Java, JavaScript supports the dynamic generation of objects.
Rather than defining the presence of fields at compile-time, the JavaScript programmer constructs empty objects and populates them with properties at runtime.
JavaScript replaces the strict hierarchical relationship between object classes with runtime prototypal inheritance.
Property access proceeds by first scanning the initial object for the requested property.
In the event that the property is absent, the lookup proceeds by recursively scanning each object in the prototype chain, following the internal \brackdbl{Prototype} property.

\subsubsection{Property Access}

Objects in JavaScript resemble hash tables, with property name-to-value bindings created, updated, and removed at runtime.
Three different syntaxes allow a programmer to access an object's properties\footnote{The presence of \code{eval} and \code{with}-blocks can modify the path of access by naming the current context object, but their presence does not change the syntax of access.}.
As shown in \autoref{list:property-access-notation} the first form does not explicitly name the object being accessed, while in the other two forms a dot or square bracket follows the name of the target object.

\lstset{caption={Syntax for Property Access},
        label={list:property-access-notation}}
\begin{jscode}
key      // property access targeting the current context object
obj.key  // property access using dot notation
obj[key] // property access using bracket notation
\end{jscode}

In the first example of \autoref{list:property-access-notation}, \FlowCore\ retrieves \code{key} from the current context object.
The lookup path may follow the internal \brackdbl{scope} chain for properties defined in an outer lexical scope.
The resulting value \code{key} carries a tag representing the union of all labels encountered on the reference path taken.

In the latter two examples of \autoref{list:property-access-notation}, \FlowCore\ first retrieves \code{obj} from the current activation object, in the same manner that it retrieves \code{key} in the first example.
Recall that \FlowCore\ does not tag the object itself, but rather tags the pointers that reference the object.
The resulting object reference \code{obj} then carries a tag representing the union of all labels encountered on the reference path taken.

In the bracket form, the interpreter first coerces the \code{key} into a string via the internal \code{ToString} function.
This coercion happens for all accesses, including numerical indexing on an array.
Assuming that the \brackdbl{ToString} method has not been overridden by the programmer, the result of the coercion carries the same label as the given \code{key}, otherwise it carries the label of the returned result from the overloaded method call.
In contrast, the dot notation contains the \code{key} as an embedded code string (requiring no coercion) that carries the label of the code source.

Once the object instance \code{obj} has been retrieved and the \code{key} calculated, the interpreter performs a hash-table lookup on the properties of that object.
In the event that an object does not itself have a value associated with the requested \code{key}, the lookup proceeds recursively through objects in the prototype chain following \brackdbl{Prototype} references.
\autoref{fig:prototype-chain} shows this access path for a generic property lookup.

\newcommand{\hashvalue}[2]{\textlangle \code{#1} \textbar\ \code{#2}\textrangle}
\newcommand{\hashbrackdbl}[2]{\textlangle \brackdbl{#1} \textbar\ \code{#2}\textrangle}
\begin{figure}[h!]
  \centering
\begin{tikzpicture}[
  cell/.style={text badly centered},
  cellpath/.style={draw=black, text badly centered}
  ]

  \node[] (lookup) at (-2cm,0cm) {};

  \matrix [draw=gray, matrix anchor=west, column sep=1.5cm] (object1) {
    & \node[cellpath] (proto1) {\hashbrackdbl{Prototype}{P}}; \\
    & \node[cell] {\vdots}; \\
    & \node[cell] {\hashvalue{value}{A}}; \\
    \node[draw=black] (table1) {}; & \node[cell] {\hashvalue{value}{B}}; \\
    & \node[cell] {\hashvalue{empty}{C}}; \\
    & \node[cell] {\hashvalue{value}{D}}; \\
    & \node[cell] {\vdots}; \\
  };
  \node[above, anchor=south west] at (object1.north west) {Object \code{obj}};

  \matrix [draw=gray, matrix anchor=west, column sep=1.5cm] at (7cm,0cm) (object2) {
    & \node[cell] (proto2) {\hashbrackdbl{Prototype}{Q}}; \\
    & \node[cell] {\vdots}; \\
    & \node[cell] {\hashvalue{value}{E}}; \\
    \node[draw=black] (table2) {}; & \node[cell] (value2B) {\hashvalue{empty}{F}}; \\
    & \node[cellpath] (valueG) {\hashvalue{valueK}{G}}; \\
    & \node[cell] {\hashvalue{empty}{H}}; \\
    & \node[cell] {\vdots}; \\
  };
  \node[above, anchor=south west] at (object2.north west) {Object \code{obj}'s Prototype};

  \node[] (prototerm) at ([xshift=3cm]proto2) {//};

  \draw[arrow] (lookup) -- node[above, sloped] {\hashvalue{obj}{O}} (table1.west);
  \draw[arrow] (table1.east) -- node[above, sloped] {\hashvalue{key}{K}} (proto1.west);
  \draw[arrow] (proto1.east) -- (table2.west);
  \draw[arrow] (table2.east) -- node[above, sloped] {\hashvalue{key}{K}} (valueG.west);
  \draw[arrow] (proto2.east) -- (prototerm);

\end{tikzpicture}
\caption{
    \label{fig:prototype-chain}
    Path of access for a property defined on an object's prototype.
    References and values follow \hashvalue{value}{label} notation.}
\end{figure}

\subsubsection{Labeling Semantics for Property Access}
As shown in \autoref{fig:prototype-chain}, property access begins with two labeled items: the object \code{obj} carrying label \code{O} and the stringified property name \code{key} carries label \code{K}.
The target value \code{valueK} ultimately found via the lookup chain also carries its own label \code{G}.
At minimum, the final label on the value resulting from the lookup incorporates labels from the starting object, the key, and the value found.
However, the lookup chain also involves labeled prototype references, so the label of the resulting value should incorporate the label of each object reference walked in the chain.
Additionally, tracking of active implicit flows demands in joining the label of the current program counter to incorporate the current security context (\autoref{sec:control-flow-stack}).

In summary, the resulting value carries a label formed by the union of
\begin{itemize}
  \item the label of each reference link taken to look up the object,
  \item the label of the stringified key,
  \item the label of each prototype link taken to look up the value,
  \item the label of the value found (or bottom if no value present),
  \item and the label of the current program counter.
\end{itemize}

Note that, as a side-effect of joining in the label of each prototype reference along the lookup path, the \code{undefined} value that results from lookup of a non-existent property might have a label very high in the security lattice.
Consequently, we identify flagrant use of values taken from extended reference chains (explicit via syntax or implicit via lookup rules) yet another source of label creep in a JavaScript program.

As a prototype implementation of information flow, \FlowCore\ did not modify all of JavaScriptCore's internal helper methods to join in each component label.
Instead \FlowCore\ takes only label of the target (post-lookup) value under operation and the label of the current program counter.
This omission accomplishes several goals simultaneously.
It simplifies implementation, omits a source of label creep, improves runtime performance by eliding label joins, and permits a prototype implementation in WebKit's JIT compiler (\autoref{ch:jitflow}).
A literature search did not reveal any other research work explicitly claiming to have implemented full prototype-chain labeling semantics. % with enough detail to retain believability.

\subsection{Functions}

The JavaScript specification~\cite{ecma} describes functions as having first-class status: they can be passed as arguments to other functions, returned as values from function calls, assigned to variables, and stored in data structures.
Additionally, functions in JavaScript do not require programmatic names and can be declared anonymous.

JavaScript does not feature the compiler-enforced access and visibility rules of class-based languages exemplified by the \code{public}, \code{private}, and \code{protected} keywords of C++ and Java.
Instead, JavaScript programs make widespread use of closures to achieve code encapsulation and data-hiding.
The JavaScriptCore interpreter supports this feature by separating the function code from an execution context, composed of three parts~\cite{ecma}:
\begin{itemize}
  \item the LexicalEnvironment, used to resolve identifier references made by code within the execution context,
  \item the VariableEnviornment, used to identify the context object that holds bindings created by variable statements and function declarations within the execution context,
  \item and the ThisBinding, used to provide the object targeted by the \code{this} keyword within the execution context.
\end{itemize}
Unlike the current context object (the target of the ThisBinding) described in \autoref{sec:variables}, the execution context remains inaccessible by any JavaScript program.

Just as \FlowCore\ labels values and object references, it also labels references to functions, supporting the first-class definitions offered by JavaScript.
At the site of storage, the label of a function depends on how it gets defined.
Functions defined by loading source code have a label representing the domain from which the code was fetched.
Functions defined during runtime execution carry the label of the current program counter at the site of definition.
When accessing a function in order to invoke a call, the label of function reference follows the same rules as provided earlier for the lookup of values (\autoref{sec:variables}).

The practice of using closures for data encapsulation and variable hiding does not affect the implementation of \FlowCore.
Instead, it only affects the storage placement of the function and consequently the path of access a programmer uses to retrieve the function for invocation.
\autoref{sec:function-calls} discusses the setup of the execution context prior to function evaluation and the mechanism for labeling the value resulting from the function call.

\subsection{Built-ins}

\begin{comment}
 - what to do with arrays, or does this fit better in design considerations?
   : Can coalesce labels on arrays?
   : label bounds checking?
 - object poisoning attack
\end{comment}

The JavaScript specification~\cite{ecma} provides numerous built-in functions and values, defined on the built-in Global Object.
Some of these built-ins have attributes that behave in a way that cannot be emulated in pure JavaScript, such as the \code{length} property of an \code{Array} object.

\FlowCore\ provides an initial bottom label for the constructor of each of these items but does not rewrite the internal functionality for label propagation.
Nor does \FlowCore\ provide special-case considerations for special attributes and methods for the built-in classes.
Rather, the implementation acquires label propagation ability through modifications made to the base \code{JSValue} datatype.

All programs, including malicious ones, retain the ability to override the built-ins by simply replacing that property on the Global Object.
For example, a running program may replace the built-in values \code{undefined} and \code{NaN} with its own definitions.
However, because of its construction at runtime, the new item carries a label dependent on the execution context, which necessarily differs from the bottom label assigned at start-up.
The presence of this label affects all later uses of the overridden item within the program.
In this manner, \FlowCore\ tracks the influence that an unexpected override may have on the rest of a JavaScript program, providing a mechanism to detect and track the influence of a malicious hijacking.

Although the implementation of \FlowCore\ does not cover every aspect of the JavaScript specification, the parts remaining are of only a practical concern.
This dissertation focuses on the implementation of a labeling framework that would support such effort and on the ramifications of attaching labels to values in a dynamic language.

\subsection{Expressions}

JavaScript, like any other computer language, supports the ability to create new values through the composition of existing values.
For example, a new numerical value, \code{x}, can be derived from the sum of two other values, \code{a} and \code{b}.

\lstset{caption={Value composition},
        label={list:value-composition}}
\begin{jscode}
var x = a + b;
// labelof(x) === label.join(labelof(a), labelof(b), labelof(pc))
\end{jscode}

An expression's resulting value depends not only on the input values, but also on the current execution context.
As a consequence of direct data-dependence in expressions, \FlowCore\ labels the result value using the join of all labels of values together with the label of the program counter.

To accomplish this task, we edited the C++ implementation of many of the operators within the JavaScriptCore interpreter to explicitly pull off the labels and perform the join as part of the computation.
Fortunately, the syntactically recursive nature of JavaScript expressions and the virtual register-machine based implementation of JavaScriptCore, permits updating each operator independently and rely on the compositional nature of the language for propagation.

As a prototype implementation, \FlowCore\ handles:
\begin{description}
  \item[Unary Math:] pre-increment, pre-decrement, post-increment, post-decrement, unary minus, and unary plus.
  \item[Binary Math:] addition, subtraction, multiplication, and division, string concatenation
  \item[Comparison:] equality, inequality, strict equality, strict inequality, less than, less than or equal to, greater than, and greater than or equal to, each for both numbers and strings.
  \item[Bitwise Operators:] shift left, shift right, shift right with zero fill, and, or, xor, and not.
\end{description}

Although the idea behind dataflow tracking through expression seems simple, \FlowCore\ derives much of its tracking capabilities through this feature.
After all, data structures comprise half of what makes a program\cite{wirth+76}.

\section{Control Flow Tracking}
\label{sec:control-flow-tracking}

Dynamically typed languages, such as JavaScript, present difficulties for tracking information dependence through control flow.
Although the automatic type coercion of values can be handled via dataflow mechanisms, the ability to dynamically dispatch on runtime input, the presence of first-class functions, and the presence of \code{eval} all conspire to increase the difficulty and decrease the scope of statically performed control flow analysis.
Consequently, \FlowCore\ undertakes only enough static control-flow analysis to instrument additional instructions (\autoref{ch:instructions}) that assist in performing label propagation during program execution.

Fortunately, JavaScript uses structured control flow constructs.
This language feature permits the use of a static analysis that calculates exactly at which point the information flow instructions introduced in \autoref{ch:instructions} need insertion into a program's instruction stream.

\FlowCore\ modifies the instruction generator of JavaScriptCore to instrument control flow stack instructions at parse time.
This modification allows \FlowCore\ to prevent certain categories of control-flow based information leaks (\autoref{sec:tracking-capabilities}) by using a control-flow stack that tracks the security label of the program counter (\autoref{sec:control-flow-stack}) at runtime.

%This section presents a high-level motivation followed by the information flow instruction instrumentation for each type of control flow construct offered by JavaScript.

\subsection{Conditional Branches}
\label{sec:conditional-branch}

We begin the discussion on control-flow tracking with the simplest example possible: the conditional branch.
This control-flow structure, particularly its reduction to jump instructions, provides a useful guideline for the complexity that comes with loops and function calls.

As exhibited by \autoref{list:2branch}, a conditional branch consists of four parts:
\begin{description}
  \item [The predicate.] \hfill \\
    A boolean that determines which branch to execute.
  \item [The true-branch.] \hfill \\
    A block of code that executes when the conditional evaluates True.
  \item [The false-branch.] \hfill \\
    An optional block of code that executes when the conditional evaluates False.
  \item [The join point.] \hfill \\
    The common end of both branches.
\end{description}

\lstset{caption={A conditional branch that contains an information leak of a secret variable using an implicit information flow.},
        label=list:2branch}
\begin{jscode}
    var pub = undefined;
    if (0 + secret) {      // the predicate
        pub = true;        // the true-branch
    } else {
        pub = false;       // the false-branch
    }
    return pub;            // the join point
\end{jscode}

%The conditional branch possesses a useful logical constraint that guides the tracking mechanism: only one of the two available paths executes.
No matter which branch executes, all of its instructions inferentially depend on the runtime value of the boolean predicate, so \FlowCore\ treats them as a code region.
That region ends at the join point of the \code{if}-statement, where the two branches merge control flow, and the instruction following no longer have execution dependence on the predicate.

The predicate may itself depend on input not supplied until runtime, so a static analysis cannot track the flow of information from predicate to branch instruction prior to execution.
The example in \autoref{list:2branch} has a (fairly useless) computation for the predicate, simply to act as a marker in the instruction stream.

The region of instructions that comprises a branch, in the simplest case, consists of a block of straight line code.
In the complex cases, the branch may contain arbitrary statements, but the JavaScript language definition limits the structure to syntactically nest in a recursive manner.
Conveniently, this property allows \FlowCore\ to use a stack data structure, that pushes up at each predicated branch and pops off at each control-flow join, to track the begin and end of each code region.

Based on the code syntax, the parser has knowledge of the begin and end points for each region, enabling it to emit instructions that the \FlowCore\ interpreter uses to track information flow dependence within either branch at execution time.
To illustrate the instrumentation of these instructions, \autoref{fig:2branch-bytecode} shows the instruction stream that results from parsing \autoref{list:2branch}.

\begin{figure}[h]
\begin{python}
code = r'''
function mybranch(secret) {
  var pub = undefined;
  if (0+secret) {
    pub = true;
  } else {
    pub = false;
  }
  return pub;
}

print(debug(mybranch))
'''
import sys
sys.path.append('..')

import jsc
j = jsc.jsc(code)
j.run()

import bytecodeformatter
bytecodeformatter.tikz_picture(j.instructions())
\end{python}
  \caption{\FlowCore\ instruction stream representing the code snippet in \autoref{list:2branch}.}
  \label{fig:2branch-bytecode}
\end{figure}

Ordinary label propagation through straight-line code ensures that the predicate value itself has an attached label.
\FlowCore\ uses this label to upgrade the program counter's label.
It then pushes the new \pclabel\ on the control flow stack, marking the entrance of a new program region.
Although the new \pclabel\ only affects instructions evaluated in the taken branch, the marking of the region applies to both branches.

The modified parser emits a \dup instruction (offset~\code{04}) to clone the current \pclabel\ and mark the beginning of the secure code region.
Next, instructions for evaluating the conditional value appear, so that they also execute under the cloned \pclabel.
The conditional value itself may be the result of an arbitrary expression, which could include function calls and shortcut evaluation of logical operators.
\FlowCore\ cannot predict its label at parse time, so a \join instruction (offset~\code{10}) immediately follows the conditional evaluation (offset~\code{05}).
%The example in \autoref{fig:2branch-bytecode} the \join instruction immediately follows the \dup instruction because the conditional value already exists in a register (\code{r0}) and does not require computation.

Prior to selecting a branch for execution (offset~\code{12}), the \join instruction (offset~\code{10}) upgrades the top of the control flow stack using the label of the conditional value computed at runtime.
All instructions in the chosen branch then execute under the new \pclabel.
The data-flow propagation rules then ensure that the information dependence from the conditional predicate propagates to values computed within that branch, via the \pclabel\ as an intermediary.
\FlowCore\ does not need to instrument additional instructions in either the true-branch (offsets~\code{15}--\code{18}) or the false-branch (offset~\code{20}), because it already applies data-flow propagation from the \pclabel\ to label the value output from each instruction.
When either side of the conditional branch finishes executing, a \popj instruction (offset~\code{23}) at the control flow join restores the \pclabel\ to its state prior to branching, by popping the label pushed at the beginning of the region (offset~\code{04}).

\subsection{Loops}

We address the loop control-flow structure by following the pattern established in analysis of the conditional branch.
When reducing the loop control-flow structure to jump instructions, we notice that it contains an implied backwards branch for repeating a block of instructions.
This pattern means that loops require additional care compared to conditional branches.

As exhibited by \autoref{list:for-loop}, a loop consists of four parts:
\begin{description}
  \item [The initialization.] \hfill \\
    Declarations of any variables or beginning state prior to the loop.
    These may occur as general instructions prior to the loop declaration or, in the case of a \code{for}-loop, as a syntactically obvious convenience.
  \item [The condition.] \hfill \\
    A boolean value that determines when the loop exits.
  \item [The loop body.] \hfill \\
    A block of code that executes for as long as the predicate holds True.
    The \code{for}-loop provides a convenient \emph{afterthought} that appears at the end of the loop body, usually used for incrementing or decrementing a loop index variable.
  \item [The loop exit.] \hfill \\
    Code that follows the loop body, executing after the loop exit.
\end{description}

\lstset{caption={Parts of a \code{for}-loop.},
        label=list:for-loop}
\begin{jscode}
  for (var x=0;      // initialization
       x < 1000;     // condition
       ++x) {        // afterthought
    print(x);        // loop body
  }
  // loop exit
\end{jscode}

Again the reduction of the loop control-flow structure to jump instructions
Because of the implied backwards branch, loops require additional care compared to conditional branches.
Specifically, \FlowCore\ must commit to a single push/pop pair surrounding the loop code region, and avoid pushing on the control-flow stack every time it evaluates the loop condition (i.e. every iteration).

As with the conditional branch, ordinary data-flow propagation through straight-line code ensures that the initialization values construct with attached labels.
Next, the loop conditional predicate executes to determine whether the loop body will run.
The predicate executes at the end of each loop iteration to control subsequent iterations of the loop body.
Conceptually, that behavior places the loop condition within the same code region as the loop body.
So the code region defining the loop begins with the initialization code, covers the loop condition and body, and ends at the loop exit.

Because the predicate of the loop may depend on runtime-supplied input, a static analysis cannot track the flow of information from predicate to loop body.
Instead, \FlowCore\ establishes a region around the loop condition and body, relying on data-flow propagation to track the dependence at runtime, by propagating the region's current \pclabel\ to labels on values generated within the loop body.
The recursively nested syntactic structure of the JavaScript language permits tracking the region with a label stack.

When \FlowCore\ evaluates the loop condition it sets the label for the code region that defines the loop.
But the loop condition controls execution of each loop body iteration.
So \FlowCore\ upgrades the label of the code region after each evaluation of the condition.
Due to the monotonicity of the join operation used to upgrade the \pclabel\ on the code region, this behavior has an interesting side-effect.
Later iterations of the loop body my execute under a label higher in the security lattice than earlier iterations of the loop body.
Naturally, successive iterations depend on earlier iterations, implying an information flow between iterations, which \FlowCore\ tracks.

Unfortunately, \FlowCore\ does not have a powerful enough analyzer to determine if subsequent iterations actually possess an information flow dependence between iterations.
The programmer may intend that each iteration be logically independent, such that a more powerful language would execute all iterations in parallel, with some loop body executions under conditionals with a high label, and others under a lower label.
In JavaScript, logically-independent iterations meant to execute under a lower label will unfortunately happen to inherit a higher label, when they occur subsequent to the execution of an iteration with a higher label.
This side-effect occurs as a result of expressing parallel logic in a single-threaded manner and forms a potential source a label creep that \FlowCore\ cannot avoid.

\begin{figure}[h]
\begin{python}
code = r'''
function mybranch() {
  for (var x=0;      // initialization
       x < 1000;     // condition
       ++x) {        // afterthought
    print(x);        // loop body
  }
}
print(debug(mybranch))
'''
import sys
sys.path.append('..')

import jsc
j = jsc.jsc(code)
j.run()

import bytecodeformatter
bytecodeformatter.tikz_picture(j.instructions())
\end{python}
  \caption{\FlowCore\ instruction stream representing the code snippet in \autoref{list:for-loop}.}
  \label{fig:for-loop-bytecode}
\end{figure}

Prior to the loop initialization code, \FlowCore\ marks the beginning of the loop region with a \dup instruction (line~\code{01}).
Because the \dup instruction changes only the height of the control-flow stack, and not the value of the label on top of the stack, the loop initialization instructions (line~\code{02}) execute under an unmodified security context.
For performance optimization reasons, JavaScriptCore places the loop condition (lines~\code{24}--\code{30}) after the loop body (lines~\code{07}--\code{18}).
Both \code{for}-loops and \code{while}-loops follow this convention, permitting only a single example (\autoref{fig:for-loop-bytecode}) to show the placement of control flow stack instructions.

Each time \FlowCore\ evaluates the loop condition, it executes a \join instruction (line~\code{28}) that upgrades the current security context for the next iteration.
Naturally, the placement of the loop condition at the tail end of the loop body causes an upgrade in every iteration.
The \join instruction does not affect the height of the control-flow stack, successfully avoiding unwanted stack growth each iteration.

The presence of the \join instruction in the conditional results in a monotonically increasing label on the loop body.
This implementation detail permits later iterations to carry a higher \pclabel\ than earlier iterations, even when these iterations do not influence each other.
\FlowCore\ makes no attempt to analyze the loop body for independence of iterations, so it cannot downgrade the loop context.

As soon as the loop condition fails to hold, \FlowCore\ executes a \popj instruction that restores the control-flow stack height to its previous level before the loop.
This action allows subsequent code to execute under the same \pclabel\ as existed before encountering the loop, regardless of how many loop iterations executed.

\subsection{Break and Continue}
\label{sec:break-and-continue}

JavaScript allows the \code{break} and \code{continue} statements to specify which loop they apply to.
This complicates the maintenance of the control-flow stack, because they cause control flow to jump out of an arbitrarily nested loop.
Such jumps can bypass the normal exit criteria of nested loops, thereby causing the control-flow stack to be out of alignment at the target location.
To maintain correct runtime-behavior \FlowCore\ handles this issue by ensuring that the instruction emitter generates the correct number of control flow pops for any nested loops prematurely exited.
A static analysis in the parser performs this computation and provides the resulting number as a parameter to the \popj instruction.

\autoref{list:break-leak} demonstrates the use of a break in control flow to construct a value identity, \code{i~==~pin}, between an loop index, \code{i}, and a secret variable, \code{pin}, with a higher label in the security lattice.
Without special consideration of the \code{break} and \code{continue} statements, malicious code could construct such identities without direct assignment, successfully avoiding detection from a data-flow propagation mechanism.
However, making use of these identities requires that the loop index, \code{i}, remains available outside of the control-flow region that constructed the equality.

\lstset{caption={Leaking a value via a break in control flow.},
        label=list:break-leak}
\begin{jscode}
function leak_global_pin() {
  var i = 0;
  while (i < 10000) {
    if (i == pin) {   // compare with secret pin
      break;
    }
    ++i;
  }
  return i; // knowing that i == pin
}
\end{jscode}

Notice that, in \autoref{list:break-leak}, no data-flow assignment modifies the loop index variable \code{i}.
Even the comparison with the secret variable \code{pin} (line~\code{3}) does not change the label attached to the index, \code{i}.
The scope of the \code{if}-statement ends prior to incrementing the index, preventing any data-flow propagation that would influence the label on the index variable \code{i}.

To combat the use of contrived control flow as a side-channel to data-flow propagation, \FlowCore\ raises the security context of the \emph{function} scope in which the \code{break} or \code{continue} statement occurs.
This action causes code following the unexpected change in control flow to execute under the same \pclabel\ as the \code{break} statement itself.
Any later use of the loop index \code{i} (line~\code{8}) then occurs under the raised security context.
The rules for data-flow propagation incorporate the \pclabel, so the result of such later computations carry the label of the condition (line~\code{3}) which controlled the break.

\begin{figure}[h]
\begin{python}
code = r'''
function leak() {
  var i = 0;
  while (i < 10000) {
    if (i == pin)
      break;
    ++i;
  }
  return i;
}
print(debug(leak))
'''
import sys
sys.path.append('..')

import jsc
j = jsc.jsc(code)
j.run()

import bytecodeformatter
bytecodeformatter.tikz_picture(j.instructions())
\end{python}
  \caption{\FlowCore\ instruction stream representing the code snippet in \autoref{list:break-leak}.}
  \label{fig:break-leak-bytecode}
\end{figure}

The arrow diagram in \autoref{fig:break-leak-bytecode} gives a visual layout of the nested control-flow structure in \autoref{list:break-leak}.
The nested \code{if}-statement (lines~\code{07}--\code{27}) scopes the break in control flow (line~\code{25}).
As explained previously (\autoref{sec:conditional-branch}), it begins with a \dup instruction (line~\code{07}) and ends with a \popj instruction (line~\code{27}).
Instructions within the body of the true-branch occur under the \pclabel\ upgraded by the loop condition, handled by the \join instruction (line~\code{17}).

In this example, the body of the true-branch contains a \code{break} statement that disrupts the ordinary control flow, resulting in the placement of a \code{jmp} instruction (line~\code{25}) that moves control to the loop exit.
Prior to this break, \FlowCore\ places a \popj instruction (line~\code{22}) that pops the label corresponding to the \code{if}-statement off the top of the control-flow stack (argument~\code{pop:1}).
The target of the break coincides with the natural end of the loop, which takes care of popping off the label (\popj instruction on line~\code{41}) that corresponds to the code region of the loop.

The \popj instruction corresponding to the break (line~\code{22}) differs from the other \popj instructions that handle the closing of the code regions corresponding to the \code{if}-statement (line~\code{27}) and \code{while}-loop (line~\code{41}).
It has an additional parameter that causes an upgrade of the function scope (argument~\code{join:2}).
In this case, the function has only one level of scope beyond the nested \code{if}-statement.

The \popj instruction for the break pops one label for the \code{if}-statement and upgrades two labels beneath, one for the \code{while}-loop and one for the function.
After the breaking the control flow, all following instructions scoped to the current function execute under the upgraded \pclabel.
The use of the \pclabel\ makes the data-flow propagation rules (\autoref{sec:data-flow-tracking}) context-aware, enabling \FlowCore\ to track the information dependence that values constructed outside of the interrupted loop have on the break condition.

\subsection{Function Calls}
\label{sec:function-calls}

JavaScript supports first-class functions, meaning that references to functions carry a label, just like references to Objects.
Entry into a function creates an \term{execution context}~\cite{ecma}, beginning with an activation object that holds the function-local variables and an \code{arguments} object that gives array-like indexable access to the function's runtime arguments and caller.
\FlowCore\ modifies the JavaScriptCore VM to establish a new code region surrounding the function body.

As part of the preamble, \FlowCore\ pushes a label onto the control-flow stack at the time it creates the execution context for the called function.
\FlowCore\ then upgrades the \pclabel\ for the function by joining in the label of the function reference, ensuring that the results of all operations within the function occur under the label of the function reference.
Finally, control transfers to the newly established function frame.

\FlowCore\ does not emit the \dup and \join instructions into the instruction stream to establish the beginning of the function's code region.
Rather, it accomplishes the same effect by direct modification of JavaScriptCore's internal stack manipulation routines.

During execution, \FlowCore\ applies the current \pclabel\ to the result of all operations, following the control-flow and data-flow implementation given previously.
\FlowCore\ makes no special consideration for function-local variables, because they behave as fields stored on the activation object.
The labeling rules also apply to implicitly defined local values, such as the function's return value, the \code{arguments} object, and any raised exception objects.
%Additionally, the labeling applies to any variables accessed along the \brackdbl{scope} chain, using the same procedures for variable access on the \brackdbl{property} chain.

\begin{comment}
function foo() {
  console.log(arguments.caller)        // undefined
  console.log(arguments.length)        // length of the argumets
  console.log(Function.caller)         // null
  console.log(foo.caller)              // code of parent function
  console.log(arguments.callee.caller) // code of parent function
  console.log(arguments.callee)        // code of self
  console.log(typeof arguments)        // object
}

foo(1,2,3,4)
\end{comment}

\subsubsection{Closures}

%http://lostechies.com/derekgreer/2012/02/17/javascript-closures-explained/
%http://javascript.info/tutorial/closures
%\url{http://jibbering.com/faq/notes/closures/#clScCh}

Because JavaScript doesn't support the \code{public}, \code{private}, and \code{protected} access modifiers of class-based languages, programmers use closures to encapsulate variables with the methods that modify them.
Douglas Crockford describes three patterns that emulate the behavior of these missing keywords~\cite{crockford+01}:

\begin{description}
  \item[Public:]
    The members of an object are all public members. Any function can access, modify, or delete those members, or add new members.
  \item[Privileged:]
    A privileged method is able to access the private variables and methods, and is itself accessible to the public methods and the outside.
    It is possible to delete or replace a privileged method, but it is not possible to alter it, or to force it to give up its secrets.
  \item[Private:]
    Private members are made by the constructor.
    They are attached to the object, but they are not accessible to the outside, nor are they accessible to the object's own public methods.
    They are accessible to private and privileged methods.
\end{description}

\autoref{list:closure-example} demonstrates the syntactical construction of these encapsulation patterns.
Notice that the existing data-flow and control-flow rules handle label propagation for all assignments and accesses.
The closure exists by virtue of JavaScriptCore's support for keeping the stack activation object alive for as long as the variables defined therein have a live reference.
\FlowCore\ makes no special consideration for label propagation in closures and derives its support for this language feature as a result of composition from support for other features.

\lstset{caption={JavaScript closures emulating public, private, and privileged concepts.},
        label={list:closure-example}}
\begin{jscode}
function Constructor(param) {
    this.public_member = param;

    var private_variable = param;
    function private_method() {
        return --private_variable > 0;
    }

    var private_self = this;
    this.privileged_method = function () {
        return private_method() ? private_self.public_member : null;
    }
}

// use at the JavaScript console
> var obj = new Constructor(1)
[object Object]
> obj.public_member
1
> obj.privileged_method()
1
> obj.privileged_method()
null
\end{jscode}

\subsubsection{Return Values}

As a result of data-flow label propagation, the return value already contains a conjunction of all labels on all data elements used in computation of the value.
\FlowCore\ modifies the return instruction to apply the current \pclabel\ to the value being returned.
This additional step enables implicit return values\footnote{All JavaScript functions return \code{undefined} by default, if the function body does not have an explicit return value.} to posses a label at least as secure as the \pclabel\ present at function exit.
It also catches any upgrade to the code region of the function, such as that caused by a break in control flow (\autoref{sec:break-and-continue}).
By modifying the implementation of the return instruction, \FlowCore\ does not need to instrument any control flow stack instructions at function return sites.

\FlowCore\ handles early returns in the same manner that it handles a break in control flow.
The code region exits with an explicit \popj instruction that upgrades the \pclabel\ of the function body, immediately before the \code{ret} instruction labels its argument with the current program counter label and returns to the calling function.

Just as it modified the stack manipulation routines to establish a code region at the callsite, \FlowCore\ also takes care to implicitly perform the equivalent of a \popj instruction to end the function's code region as part of the function's epilogue.
This action occurs in all cases as part of transferring control to the caller function and does not engender instrumentation of the \popj instruction into the instruction stream.

\subsubsection{Labelling of the Function Reference}

When used within a host application, such as the WebKit web browser, \FlowCore\ supports labeling of the function reference.
The setting of this label breaks down into two cases:
\begin{description}
 \item [A script declares the function.]
  When the host environment hands a script to the JavaScript VM, it has the option of labeling that script, and the function objects created from parsing it, with a security principal.
  For example, a modified version of WebKit can tag scripts (and the objects described within) with a label that indicates their domain of origin.
  During execution of the script, data-flow label propagation ensures that \FlowCore\ executes the functions with the label initially attached by the host application.
 \item [Execution defines a function at run time.]
   Just as with any object, the current program counter implicitly labels the \code{JSvalue} holding the function reference at the time of that function's creation.
  Whether stored in a variable for a later call, anonymously passed around or returned, or immediately called, \FlowCore\ uses the attached label to establish the execution context at function invocation time.
  All code within the function then executes under a label at least as secure as the \pclabel\ at the time of the function's creation.
  If the reference undergoes data-flow in a secure region, \FlowCore\ upgrades the attached label by the rules of control-flow propagation.
\end{description}


\begin{comment} % web1/../jsc does not handle exceptions
\subsection{Exceptions}
\label{sec:exceptions}
Exceptions represent a substantial challenge to information flow security, because a \code{throw} permits any called function to create an early return that crosses multiple function boundaries.
To complicate security issues further, JavaScript supports the \code{try}, \code{catch}, \code{finally} triplet of keywords.

\begin{figure}[h]
\begin{python}
code = r'''
function leak() {
  try {
    print(beg);
  } catch (ex) {
    print(ex);
  } finally {
    print(fin);
  }
}
print(debug(leak))
'''
import sys
sys.path.append('..')

import jsc
j = jsc.jsc(code)
j.run()

import bytecodeformatter
bytecodeformatter.tikz_picture(j.instructions())
\end{python}
  \caption{\FlowCore\ instruction stream representing the code snippet in \autoref{list:break-leak}.}
  \label{fig:gorn}
\end{figure}

The exception handling region of the \code{try}-block begins with a \dup instruction.
As a conservative precaution, when the interpreter encounters a \code{throw} statement, it takes care to first cloak the exception object that is to be returned to the exception handler using the current \pclabel.
Once the interpreter finds the appropriate handler, it pops all activation frames within the call chain.
Control flow then transfers to the corresponding \code{catch}-block where a \code{POPJ\_CFLABEL} instruction upgrades the entire control flow stack of the handling function using the label taken from the exception object.
Taking this action prevents implicit information leaks that might occur due to exiting the \code{try}-block early.
Such leaks are analogous to the \code{break} and \code{continue} (\autoref{sec:break-and-continue}).

The \code{finally}-block always executes using the current \pclabel, which is provided either by finishing the \code{try}-block or from catching an exception and executing the \code{catch}-block.
\end{comment}

\subsection{Eval}
\label{sec:eval}
\FlowCore\ treats the \code{eval} feature in a manner similar to other function calls.
A call to \code{eval} first calls the parser, which compiles the string into an instruction stream.
As a result of passing through the parser, this stream contains all of the control flow stack instructions just as a normal script would.
That instruction stream then executes inside a code region constructed by the \FlowCore\ interpreter.
The parameter string passed into the \code{eval} provides the initial \pclabel\ for the new execution context.

\section{Verification}

In addition to the modifications made to JavaScriptCore, the \FlowCore\ projects also contains private test cases that ensure that correct label propagation for each of the control-flow structures mentioned in \autoref{sec:control-flow-tracking}, and the data-flow operations mentioned in \autoref{sec:data-flow-tracking}.
\FlowCore\ correctly identifies active implicit flows represented in the test suite, including the ``leak pin'' examples, \autoref{list:2branch}, \autoref{list:for-loop}, and \autoref{list:break-leak}.
Although this effort does not substitute for a proof of correctness, it does give us confidence that our implementation faithfully follows the approach outlined in this thesis.

To ensure that \FlowCore\ places all of the control flow stack instructions appropriately, the development version also executes an abstract interpreter that tracks the control-flow stack height at every instruction of a compiled method.
This analysis covers \emph{all} possible executions paths for every method parsed, ensuring that \FlowCore\ never instruments control flow stack instructions that might cause a runtime misalignment of the control-flow stack.
\FlowCore\ can run this verification over all of the more than 2,000 tests in the SpiderMonkey testing suite, which Mozilla uses to detect regressions for every code change.

% \section{Evaluation}
% \label{sec:evaluation}
% To include an instruction count evaluation:
% check ./2010_jsflowpaper
% check ./2011_esorics
