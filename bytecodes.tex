
\newcommand{\popj}{\code{POPJ\_CFLABEL} }
\newcommand{\dup}{\code{DUP\_CFLABEL} }
\newcommand{\join}{\code{JOIN\_CFLABEL} }

\chapter{Control Flow Instructions}
\label{ch:instructions}

Typically, a host application which supports an embedded programming language does so to increase end-user functionality.
For example, a web browser supports JavaScript to enable more interactive pages.
At the time developers introduce the ability to program their application, focus usually rests on extending existing functionality rather than any security implications raised by the ability to run user provided programs.
Side-effects of this prioritization can be seen in today's web ecosystem.

Because of an early and rapid rise in electronic commerce, web browsers now often manipulate, process, and relay sensitive information, including personal financial data.
A browser's support for JavaScript means that it is possible for malicious code to steal the valuable information stored by the browser.
Recall that web browser architecture lacks (and sometimes impedes) important security properties (\autoref{ch:motivation}).
This state of affairs makes web sites a prime target for injected code attacks.
Consequently, the combination of historically poor security practices and the popularity of the web makes web browsers an ideal case study for retrofitting security into embedded language platforms.

Rather than fret over distinguishing between legitimate and malicious code (or buggy legitimate code), \FlowCore\ performs information tracking on all executed code.
This approach catches all malicious behavior defined by some security policy, forcing conformance even on trusted code.
\FlowCore\ adds information flow tracking infrastructure to JavaScriptCore.
The retrofitting of security into an established and mature VM occurs as two components:
(1) labeling of the data types (\autoref{ch:system-design}) and
(2) the instrumentation of instructions for managing runtime data structures such as the control flow stack (\autoref{sec:control-flow-stack}).
This chapter addresses the design of the instrumented instructions.

\section{The Necessity for New Instructions}

During initial implementation, I first attempted to manipulate the control flow stack by modifying the functionality of existing instructions.
However, this approach met with several obstacles which motivate the introduction of new instructions for maintaining the control flow stack.
These obstacles are not specific to either JavaScriptCore or SpiderMonkey, but originate from fall-through execution paths common to many languages.
The technique of extending the instruction set generalizes to other dynamically typed language runtimes.

When examining the instruction stream, the merge point of an \code{if-then-else} construct has no special distinguishing feature.
In some paths, a jump instruction targets the merge point, while in other paths execution arrives at the merge point via a fall-through.
Additionally, the instruction present at the merge point could be any of the existing instructions implemented by the VM.
Neither the instructions comprising the arrival path nor the instruction at the merge point itself can serve as a unique marker for identifying a merge point.
Because no runtime mechanism can identify the merge point based solely on a single path's sequence of executed instructions, \FlowCore\ instruments a \popj instruction at every merge point.
Not only does this instruction serve as a marker which locates the merge point, but it also performs the appropriate action on the control flow stack.

A more subtle difficulty occurs at the beginning of conditional branch and loop structures.
Primitive underlying compare-and-jump instructions serve to easily identify these these points.
Examination of the target offset of the jump instruction can even distinguish loops from a conditional branch.
Loops have a backward branch (negative offset) while all conditional branches point forward (positive offset).
Naively, I thought it might be possible to modify the behavior of the compare-and-jump instructions to push a label onto the control flow stack.
However, this approach produces an erroneous execution in loops: every iteration in a loop evaluates the conditional instruction, causing a push which breaks alignment of the control flow stack with respect to the execution history of program counter.
To ensure that only one label push occurs at entry into a loop, \FlowCore\ instruments a \dup instruction in the loop header.

Given the introduction of two instructions for manipulating the control flow stack, the \FlowCore\ framework can now reliably keep the 1-1 correspondence between labels on the stack and branches in control flow taken at runtime.
However, the evaluation of a conditional instruction also implies an upgrade to a new security context.
To satisfy this additional requirement, \FlowCore\ introduces the \join instruction, which upgrades the label on the top of the control flow stack using the label conditional controlling the branch.
Inserting this instruction between the computation of a conditional value and its use as a control flow branch allows both looping and branching constructs to compute the correct security context.

Treatment of return statements requires further analysis
\FlowCore\ must take care to align the control flow stack height in the event that a return occurs inside a nested code block.
A translation of the return into a three step process accomplishes this task.
First, label the return value using the current top of the control flow stack (i.e. the \pclabel) and cache the value in the stack frame.
Second, instrument a \popj to restore the control flow stack height.
Third, return the properly labeled value and tear-down the function.
In a register machine, such as JavaScriptCore, the return instruction implementation can perform all three steps, by extending the return instruction opcode with an immediate value representing the control flow stack depth.

\section{Control Flow Stack Instruction Details}

The JavaScript VM first compiles each script into an instruction stream before beginning interpretation.
\FlowCore\ modifies the parser to produce an instruction stream that differs only by the addition of control flow instructions which track and record control flow paths executed at runtime.
During parsing, a static analysis provides the instruction emitter knowledge of nesting levels and control flow depth.
This information determines the values of parameters which control the number of pushes, pops, or joins carried out by the control flow stack at runtime.
To ensure that the parser performs instrumentation correctly, an abstract interpreter verifies, over all possible paths, a consistent control flow depth for each instruction in the stream.
Using the instrumented instructions at runtime, \FlowCore\ maintains a 1-1 correspondence between the number of labels on the control flow stack and the number of control flow branches taken during program execution.

\lstset{caption={Hypothetical information leak of secret variable \code{pin}, using an active implicit information flow.},
        label=list:steal-pin}
\begin{jscode}
function steal_pin() {
  for (var i=0; i < 100000; ++i) {
    if (i == pin) break;
  }
  return i;
}
\end{jscode}

The code sample in \autoref{list:steal-pin} contains control flow structures, such as a \texttt{for}-loop, \texttt{break} statement, and \texttt{return} statement which allows us to examine the placement of the control flow stack instructions in greater detail.
An attacker manages to inject the \code{steal\_pin} function, manufactured so that, at the end of execution, the local variable \code{i} contains the same value as the secret variable \code{pin}.

Despite the fact that other, more direct mechanisms can achieve this relationship, the example highlights lesser used control flow constructs, such as the \texttt{break} statement, and the impact these constructs have on maintaining the control flow stack height.

\begin{figure}[h]
\begin{python}
code = r'''
function steal_pin() {
  for (var i=0; i < 100000; ++i) {
    if (i == pin) break;
  }
  return i;
}

print(debug(steal_pin))
'''
import sys
sys.path.append('..')

import jsc
j = jsc.jsc(code)
j.run()

import bytecodeformatter
bytecodeformatter.tikz_picture(j.instructions())
\end{python}
  \caption{\FlowCore\ instruction stream representing the code snippet in \autoref{list:steal-pin}.}
  \label{fig:steal-pin-bytecode}
\end{figure}

\subsection{\dup}

\begin{samepage}
\begin{description}
  \item[Operation] \hfill \\
    Duplicate the top label of the control flow stack.
  \item[Control Flow Stack] \hfill \\
    \ldots, label, $\Rightarrow$ \ldots, label, label
\end{description}
\end{samepage}

The \dup instruction duplicates the top of the control flow stack.
\FlowCore\ places this instruction before every control flow branch.
In many cases, this instruction pairs with a \join instruction which then upgrades the top of the control flow stack after evaluating the boolean condition of the branch.
In all cases, a corresponding \popj instruction later delineates the end of the secure region.

As shown in \autoref{fig:steal-pin-bytecode}, the loop header occurs after the loop body.
A \dup instruction at offset~\code{01} occurs prior to evaluation of the loop initialization code.
The presence of this instruction prepares the control flow stack for the secure region delineated by the loop.
A corresponding \popj instruction at offset~\code{41} occurs on a fallthrough out of the loop restoring the control flow stack height.
A second secure region, delineated by the \code{if}-statement inside the loop, can be found with a \dup instruction at offset~\code{07} and its corresponding \popj instruction offset~\code{27}.

% Was true in Firefox, but not true in FlowCore
% As can be seen at offset , our system also inserts an additional \texttt{DUP\_CFLABEL} instruction at the beginning of every function.
% This instruction provides each function with an additional label on the control flow stack that clearly delineates the function boundary, and provides an explicitly labeled operating context for all calculations performed within the function body.
% Before the function returns, a corresponding \texttt{POP\_CFLABEL} instruction (line~\texttt{56}) restores the state of the control flow stack.



\subsection{\join}
\label{sec:join-cflabel}

\begin{samepage}
\begin{description}
\item[Operation] \hfill \\
 Upgrade the label at the top of the control flow stack by performing a lattice join with the label of the topmost value of the operand stack.
\item[Control Flow Stack] \hfill \\
 \ldots, label\subscript{a} $\Rightarrow$ \ldots, label\subscript{a} $\sqcup$ label\subscript{b}
\end{description}
\end{samepage}

A \join instruction supports upgrading the label of the program counter by joining the top of the control flow stack with the label of a given value.

This instruction is necessary for supporting loop structures that continue or exit based on a boolean condition evaluated at runtime.
Because the condition depends on a runtime evaluation, each iteration through the loop may carry a different security label.

Our system retains the successive joins of all iterations as it progresses through the loop.
A side effect of this design means that the evaluation of last iteration in a \code{for}-\code{in} loop over an array might occur under a higher security label than the first iteration.
For example, this situation occurs when the array consists of heterogeneously labeled fields.
Although finding ways to prevent such joins is worthy of further research, I speculate that doing so safely would require analysis proving non-interference between successive iterations.

In the running example (\autoref{fig:steal-pin-bytecode}), the \join instruction at offset~\code{36} takes care of upgrading the current execution context at each iteration of the \texttt{for}-loop.
For the simple loop given in the example, upgrading the top of the control flow stack is wasteful, because every iteration occurs under the same security context.
\FlowCore\ does not currently perform a more extensive analysis that would help identify this situation and optimize the join away.
Inside the \texttt{for}-loop, a \join instruction at offset~\code{17} upgrades the program counter based on the condition of the \texttt{if}-statement.

Note that incrementing the loop index variable (offset~\texttt{30}) occurs outside the context of the inner \texttt{if}-statement.
Even though we, as programmers, can see that the \code{break} statement enforces a dependence of the loop index variable on the secret variable \texttt{pin}.
\FlowCore\ therefore contains another instruction which enables tracking this dependence over the \code{break} statement.

\subsection{\popj}

\begin{samepage}
\begin{description}
\item[Operation] \hfill \\
 Pop $p$ labels from the top of the control flow stack, then perform a lattice join on each of the next $j$ labels on the control flow stack with the previous topmost label.
\item[Control Flow Stack] \hfill \\
  \ldots, label\subscript{i}, label\subscript{i+1} \ldots, label\subscript{i+j}, label\subscript{i+j+1}, \ldots, label\subscript{i+j+p}\\
 $\Rightarrow$
 \ldots, label\subscript{i}, label\subscript{i+1} $\sqcup$ label\subscript{i+j+p}, \ldots, label\subscript{i+j} $\sqcup$ label\subscript{i+j+p}
\end{description}
\end{samepage}

The \popj instruction carries two parameters: $p$, which specifies how many levels of control flow to pop, and $j$, which specifies how many further control flow levels that should be upgraded.
When the interpreter encounters a \popj instruction, it first saves the current top of the control flow stack, then it pops $p$ levels, and finally in-place joins $j$ more levels using the previously saved top.

In its primary role, the \popj instruction marks the position of every control flow merge and serves to pop a label from the control flow stack.
In the event that many control flow paths merge at the same point, the \popj instruction carries a parameter $p$, which indicates how may merges coincide.
For example, this situation may occur during an early return from within a nested loop.

In the example shown in \autoref{list:steal-pin}, both the \code{for}-loop and the \code{if}-statement each require only a single label to be popped from the control flow stack.
The \popj instruction at offset~\code{41} marks the end of the \code{for}-loop and the \popj instruction at offset~\code{27} marks the merge point of the \code{if}-statement.
Both of these occurrences pop a single secure lexical region from the current control flow stack, restoring it to the height it had prior to entry of the control structure, according to the rules in \autoref{sec:control-flow-stack}.

The presence of the second argument, $j$, which gives a depth of how many further control flow scopes should be upgraded after popping, enables \FlowCore\ to correctly handle \code{break} and \code{continue} statements.
These statements cause a divergence in control flow from within a nested scope out to a lexical outer scope.
As shown in the example in \autoref{list:steal-pin}, the \code{break} statement enforces a equality of the secret variable, \code{pin} and the loop index variable, \code{i}.
Having established this relationship, the malicious code can pilfer information via the variable $i$ because JavaScript semantics cause loop index variables declared with the \code{var} keyword to be promoted to function-level scope.
As a result, \FlowCore\ conservatively upgrades the entire function context via the joining operation incorporated into the \popj instruction.

When the nested \code{break} statement executes (\autoref{list:steal-pin}), the control flow stack contains three labels: one for the function, one for the \code{for}-loop, and one for the \code{if}-statement.
As shown in \autoref{fig:steal-pin-bytecode}, prior to exiting the loop due to the \code{break} statement, a \popj instruction at offset~\code{22} adjusts the control flow stack by popping the label of the \code{if}-statement (parameter $p$=1) and upgrades both the \code{for} loop and the current function scope (parameter $j$=2).
The \code{for}-loop then exits and the interpreter pops one label from the control stack (offset \code{41}), leaving only the label for the function scope left on the stack.

As noted previously, the inner \code{if}-statement does not directly influence the label attached to the loop index variable,~\code{i}.
Without upgrading this label, the \code{return} at line~\code{5} of \autoref{list:steal-pin} leaks the information of the secret variable \code{pin}.
However, the \popj instruction at offset~\code{22} upgrades the entire function context.
So any operations taking place after the occurrence of the \code{break} statement execute under a label at least as secure as the scope in which the \code{break} resides.
In particular, the \code{ret} instruction at offset~\code{44} executes under the upgraded label.
\FlowCore\ modifies the \code{ret} instruction to upgrade the label of the returned value by joining it with the label of the current execution context.
This action tracks the information flow demonstrated by \autoref{list:steal-pin}.



